/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	function webpackJsonpCallback(data) {
/******/ 		var chunkIds = data[0];
/******/ 		var moreModules = data[1];
/******/ 		var executeModules = data[2];
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(data);
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 		// add entry modules from loaded chunk to deferred list
/******/ 		deferredModules.push.apply(deferredModules, executeModules || []);
/******/
/******/ 		// run deferred modules when all chunks ready
/******/ 		return checkDeferredModules();
/******/ 	};
/******/ 	function checkDeferredModules() {
/******/ 		var result;
/******/ 		for(var i = 0; i < deferredModules.length; i++) {
/******/ 			var deferredModule = deferredModules[i];
/******/ 			var fulfilled = true;
/******/ 			for(var j = 1; j < deferredModule.length; j++) {
/******/ 				var depId = deferredModule[j];
/******/ 				if(installedChunks[depId] !== 0) fulfilled = false;
/******/ 			}
/******/ 			if(fulfilled) {
/******/ 				deferredModules.splice(i--, 1);
/******/ 				result = __webpack_require__(__webpack_require__.s = deferredModule[0]);
/******/ 			}
/******/ 		}
/******/ 		return result;
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// Promise = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		"ui_timeseries": 0
/******/ 	};
/******/
/******/ 	var deferredModules = [];
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/ 	var jsonpArray = window["webpackJsonp"] = window["webpackJsonp"] || [];
/******/ 	var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
/******/ 	jsonpArray.push = webpackJsonpCallback;
/******/ 	jsonpArray = jsonpArray.slice();
/******/ 	for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
/******/ 	var parentJsonpFunction = oldJsonpFunction;
/******/
/******/
/******/ 	// add entry module to deferred list
/******/ 	deferredModules.push(["./web-server/plugins/slycat-timeseries-model/js/ui.js","vendors~slycat_page~slycat_project~slycat_projects~ui_cca~ui_parameter_image~ui_parameter_plus~ui_ru~29e28113","vendors~slycat_page~slycat_project~slycat_projects~ui_cca~ui_parameter_image~ui_parameter_plus~ui_ti~7afcd8b9","vendors~ui_cca~ui_parameter_image~ui_parameter_plus~ui_timeseries","vendors~ui_cca~ui_parameter_image~ui_timeseries","vendors~ui_timeseries","slycat_page~slycat_project~slycat_projects~ui_cca~ui_parameter_image~ui_parameter_plus~ui_run_comman~247387c4","slycat_page~slycat_project~slycat_projects~ui_cca~ui_parameter_image~ui_parameter_plus~ui_timeseries","ui_cca~ui_parameter_image~ui_parameter_plus~ui_timeseries","ui_parameter_plus~ui_timeseries"]);
/******/ 	// run deferred modules when ready
/******/ 	return checkDeferredModules();
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/css-loader/index.js!./web-server/plugins/slycat-timeseries-model/css/ui.css":
/*!*****************************************************************************************!*\
  !*** ./node_modules/css-loader!./web-server/plugins/slycat-timeseries-model/css/ui.css ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var escape = __webpack_require__(/*! ../../../../node_modules/css-loader/lib/url/escape.js */ \"./node_modules/css-loader/lib/url/escape.js\");\nexports = module.exports = __webpack_require__(/*! ../../../../node_modules/css-loader/lib/css-base.js */ \"./node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.i, \"/* Copyright (c) 2013, 2018 National Technology and Engineering Solutions of Sandia, LLC . Under the terms of Contract  DE-NA0003525 with National Technology and Engineering Solutions of Sandia, LLC, the U.S. Government  retains certain rights in this software. */\\n\\n.ui-layout-resizer\\n{\\n  background-color: #ddc;\\n}\\n.ui-layout-toggler\\n{\\n  background-color: #ccb;\\n}\\n.ui-layout-resizer-open.ui-layout-resizer-hover, .ui-layout-resizer-dragging, .ui-layout-toggler-hover\\n{\\n  background-color: #fc6;\\n}\\n.ui-layout-pane, .ui-layout-container\\n{\\n  background: white;\\n  padding: 0;\\n  border: 0;\\n  margin: 0;\\n}\\n\\n#edit-model-button,\\n#rerun-timeseries-button\\n{\\n  float: right;\\n}\\n\\n/* cluster table styles */\\n\\n#cluster-pane\\n{\\n  z-index: 3 !important; /* Required to make bootstrap dropdowns appear over lower panes */\\n}\\n#controls {\\n  margin: 2px 0px;\\n}\\n.center {\\n  text-align: center;\\n}\\n\\n#cluster-viewer\\n{\\n  margin: 5px;\\n  border-collapse: collapse;\\n}\\n#cluster-viewer td,\\n#cluster-viewer th\\n{\\n  padding: 3px;\\n}\\n#cluster-viewer td.output\\n{\\n  background: #dbd9eb;\\n  cursor: pointer;\\n}\\n#cluster-viewer td.output.selected\\n{\\n  background: #7767b0;\\n  color: white;\\n}\\n\\n/* dendrogram styles */\\n#dendrogram-pane #dendrogram-sort-control \\n{\\n  position: absolute;\\n  bottom: 0px;\\n  left: 0px;\\n  cursor: pointer;\\n  background: #DBD9EB url(\" + escape(__webpack_require__(/*! ../../../img/sort-dendrogram.png */ \"./web-server/img/sort-dendrogram.png\")) + \") no-repeat center center;\\n  padding: 4px;\\n  margin: 0 0 5px 18px;\\n  height: 17px;\\n  min-width: 17px;\\n}\\n\\n#dendrogram-pane #dendrogram-sort-control.selected\\n{\\n  background: #7767B0 url(\" + escape(__webpack_require__(/*! ../../../img/sort-dendrogram-selected.png */ \"./web-server/img/sort-dendrogram-selected.png\")) + \") no-repeat center center;\\n  color: #FFFFFF;\\n  cursor: default;\\n}\\n\\n#dendrogram-pane #dendrogram-controls \\n{\\n  position: absolute;\\n  top: 0px;\\n  left: 0px;\\n  margin: 5px 0 0px 18px;\\n}\\n\\n#dendrogram-viewer .node .glyph circle\\n{\\n  stroke: grey;\\n}\\n\\n#dendrogram-viewer .node.selected .glyph circle\\n{\\n  fill: #7767b0 !important;\\n  stroke: black;\\n}\\n\\n#dendrogram-viewer .node .glyph text\\n{\\n  cursor: pointer;\\n}\\n\\n#dendrogram-viewer .node .subtree\\n{\\n  cursor: pointer;\\n}\\n\\na \\n{\\n  cursor: pointer;\\n}\\n\\n#dendrogram-viewer .node .subtree path\\n{\\n  stroke: none;\\n}\\n\\n/* Hiding the additional glyph initially */\\n#dendrogram-viewer .node .subtree path.filled-glyph\\n{\\n  display: none;\\n}\\n/* Showing it for selected nodes */\\n#dendrogram-viewer .node.selected .subtree path.filled-glyph\\n{\\n  display: inline;\\n}\\n\\n#dendrogram-viewer .node.selected .subtree text\\n{\\n  fill: white;\\n}\\n\\n#dendrogram-viewer .node .sparkline path\\n{\\n  fill: none;\\n  stroke: black;\\n}\\n\\n#dendrogram-viewer .link\\n{\\n  fill: none;\\n  stroke: #C9C9C9;\\n}\\n\\n/* waveform styles */\\n\\n#waveform\\n{\\n  width: 1000px;\\n  height: 700px;\\n}\\n\\n/* data table styles */\\n\\n#data-pane\\n{\\n  overflow: auto;\\n}\\n\\n/* Waveform Progress Indicator */\\n#waveform-progress,\\n#waveform-selection-progress\\n{\\n    background-color: transparent;\\n    position: absolute;\\n    left: 50%;\\n    top: 50%;\\n    width: 200px;\\n    height: 200px;\\n    margin: -100px 0 0 -100px;\\n    display: none;\\n}\\n#waveform-selection-progress\\n{\\n  z-index: 1;\\n}\\n#waveform-selector-progress {\\n  background-color: transparent;\\n  position: absolute;\\n  left: 0px;\\n  top: 3px;\\n  width: 100%;\\n  height: 15px;\\n  text-align: center;\\n  display: none;\\n}\\n#waveform-selector-progress-wrapper {\\n  display: none;\\n}\\n#waveform-pane:hover #waveform-selector-progress-wrapper {\\n  display: block;\\n}\\n/* Use these colors for the dark night mode */\\n#waveform-viewer.nightMode,\\n.nightMode rect.selectionMask\\n{\\n  background-color: #333333;\\n  fill: #333333;\\n  fill-opacity: 0.5;\\n}\\n/* Use these colors for the white day mode */\\n#waveform-viewer.dayMode,\\n.dayMode rect.selectionMask\\n{\\n  background-color: white;\\n  fill: white;\\n  fill-opacity: 0.7;\\n}\\n\\n#waveform-viewer .waveform path.unselected {\\n  stroke-width: 1;\\n  fill: none;\\n  stroke-linecap: round;\\n}\\n#waveform-viewer .waveform path.unselected:hover {\\n  stroke-width: 4;\\n}\\n#waveform-viewer .selection path.highlight {\\n  stroke-width: 4.0;\\n  fill: none;\\n  stroke-linecap: round;\\n}\\n#table\\n{\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  right: 0;\\n  bottom: 0;\\n}\\n#dendrogram-sparkline-backdrop {\\n  height: 100%;\\n  width: 130px;\\n  position: absolute;\\n  right: 0;\\n  z-index: -1;\\n}\\n#dendrogram-viewer g.sparkline path {\\n  stroke-linecap: round;\\n}\\n#dendrogram-viewer g.sparkline path:hover,\\n#dendrogram-viewer g.sparkline path.highlight\\n{\\n  stroke-width: 4px;\\n}\\n#dendrogram-viewer g.sparkline path.highlight {\\n  \\n}\\n#dendrogram-viewer g.sparkline path.nullValue {\\n  stroke-dasharray: 2px, 2px;\\n}\\n#dendrogram-viewer g.sparkline path.highlight.nullValue {\\n  stroke-dasharray: 2px, 5px;\\n}\\n.legend-axis path,\\n.legend-axis line,\\n.x-axis path, \\n.y-axis path\\n{\\n  fill: none;\\n  stroke: black;\\n  shape-rendering: crispedges;\\n}\\n\\n#color-switcher ul.dropdown-menu\\n{\\n  background-color: #F2F2F2;\\n}\\n.bootstrap-styles #color-switcher .dropdown-menu > li > a:hover\\n{\\n  background-color: #E4E4E4;\\n}\\n.bootstrap-styles #color-switcher .dropdown-menu > .active > a:hover\\n{\\n  background-color: #337AB7;\\n}\\n#controls  ul.dropdown-menu  {\\n  max-height: 300px;\\n  overflow-y: auto;\\n}\\n\", \"\"]);\n\n// exports\n\n\n//# sourceURL=webpack:///./web-server/plugins/slycat-timeseries-model/css/ui.css?./node_modules/css-loader");

/***/ }),

/***/ "./web-server/plugins/slycat-timeseries-model/css/ui.css":
/*!***************************************************************!*\
  !*** ./web-server/plugins/slycat-timeseries-model/css/ui.css ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../../../../node_modules/css-loader!./ui.css */ \"./node_modules/css-loader/index.js!./web-server/plugins/slycat-timeseries-model/css/ui.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../../../node_modules/style-loader/lib/addStyles.js */ \"./node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}\n\n//# sourceURL=webpack:///./web-server/plugins/slycat-timeseries-model/css/ui.css?");

/***/ }),

/***/ "./web-server/plugins/slycat-timeseries-model/js/chunker.js":
/*!******************************************************************!*\
  !*** ./web-server/plugins/slycat-timeseries-model/js/chunker.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function($) {\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.is_little_endian = is_little_endian;\nexports.get_model_arrayset_metadata = get_model_arrayset_metadata;\nexports.cast_array_buffer = cast_array_buffer;\nexports.get_model_array_attribute = get_model_array_attribute;\nexports.get_model_arrayset = get_model_arrayset;\n/* Copyright (c) 2013, 2018 National Technology and Engineering Solutions of Sandia, LLC . Under the terms of Contract  DE-NA0003525 with National Technology and Engineering Solutions of Sandia, LLC, the U.S. Government  retains certain rights in this software. */\nvar arrayset_metadata_cache = exports.arrayset_metadata_cache = {};\nvar arrayset_metadata_retrieval_inprogress = exports.arrayset_metadata_retrieval_inprogress = {};\nvar arrayset_metadata_callbacks = exports.arrayset_metadata_callbacks = {};\n\nfunction is_little_endian() {\n  if (window.result === undefined) window.result = new Uint32Array(new Uint8Array([1, 2, 3, 4]).buffer)[0] === 0x04030201;\n  return window.result;\n}\n\n// Retrieve an array attribute's metadata asynchronously, calling a callback when it's ready ...\nfunction get_model_array_attribute_metadata(parameters, dfd) {\n  return $.ajax({\n    url: parameters.server_root + \"models/\" + parameters.mid + \"/arraysets/\" + parameters.aid + \"/metadata?arrays=\" + parameters.array,\n    contentType: \"application/json\",\n    success: function success(result) {\n      parameters.metadata = result.arrays[0];\n      if (parameters.metadataSuccess !== undefined) {\n        parameters.metadataSuccess(parameters);\n      } else {\n        parameters.success(parameters);\n      }\n    },\n    error: function error(request, status, reason_phrase) {\n      if (parameters.error) parameters.error(request, status, reason_phrase);\n    },\n    always: function always() {\n      dfd.resolve();\n    }\n  });\n}\n\n// Retrieve an arrayset's metadata asynchronously, calling a callback when it's ready ...\nfunction get_model_arrayset_metadata(parameters) {\n  // It's cached, so just execute callback with cached metadata\n  if (arrayset_metadata_cache[parameters.server_root + parameters.mid + parameters.aid] !== undefined) {\n    parameters.metadata = arrayset_metadata_cache[parameters.server_root + parameters.mid + parameters.aid];\n    if (parameters.metadataSuccess !== undefined) {\n      parameters.metadataSuccess(parameters);\n    } else {\n      parameters.success(parameters);\n    }\n  }\n  // It's being cached now, so add callback to queue\n  else if (arrayset_metadata_retrieval_inprogress[parameters.server_root + parameters.mid + parameters.aid]) {\n      var callback = parameters.metadataSuccess !== undefined ? parameters.metadataSuccess : parameters.success;\n      arrayset_metadata_callbacks[parameters.server_root + parameters.mid + parameters.aid].push({ callback: callback, parameters: parameters });\n    }\n    // It's not in the cache and it's not being cached, so retrieve it and execute callback queue\n    else {\n        arrayset_metadata_retrieval_inprogress[parameters.server_root + parameters.mid + parameters.aid] = true;\n        var callback = parameters.metadataSuccess !== undefined ? parameters.metadataSuccess : parameters.success;\n        if (arrayset_metadata_callbacks[parameters.server_root + parameters.mid + parameters.aid] === undefined) {\n          arrayset_metadata_callbacks[parameters.server_root + parameters.mid + parameters.aid] = [];\n        }\n        arrayset_metadata_callbacks[parameters.server_root + parameters.mid + parameters.aid].push({ callback: callback, parameters: parameters });\n\n        $.ajax({\n          url: parameters.server_root + \"models/\" + parameters.mid + \"/arraysets/\" + parameters.aid + \"/metadata\",\n          contentType: \"application/json\",\n          success: function success(metadata) {\n            arrayset_metadata_cache[parameters.server_root + parameters.mid + parameters.aid] = metadata;\n            arrayset_metadata_retrieval_inprogress[parameters.server_root + parameters.mid + parameters.aid] = false;\n            // Execute callback queue\n            for (var i = 0; i < arrayset_metadata_callbacks[parameters.server_root + parameters.mid + parameters.aid].length; i++) {\n              var callback_parameters = arrayset_metadata_callbacks[parameters.server_root + parameters.mid + parameters.aid][i].parameters;\n              callback_parameters.metadata = metadata;\n              arrayset_metadata_callbacks[parameters.server_root + parameters.mid + parameters.aid][i].callback(callback_parameters);\n            }\n          },\n          error: function error(request, status, reason_phrase) {\n            if (parameters.error) parameters.error(request, status, reason_phrase);\n          }\n        });\n      }\n}\n\n// Cast a generic arraybuffer to a typed array, with an optional offset and\n// count.  Note that offset and count are measured in elements, not bytes.\nfunction cast_array_buffer(buffer, type, offset, count) {\n  if (type == \"int32\") {\n    if (offset !== undefined) return new Int32Array(buffer, offset * 4, count);else return new Int32Array(buffer);\n  } else if (type == \"int16\") {\n    if (offset !== undefined) return new Int16Array(buffer, offset * 2, count);else return new Int16Array(buffer);\n  } else if (type == \"int8\") {\n    if (offset !== undefined) return new Int8Array(buffer, offset, count);else return new Int8Array(buffer);\n  } else if (type == \"uint32\") {\n    if (offset !== undefined) return new Uint32Array(buffer, offset * 4, count);else return new Uint32Array(buffer);\n  } else if (type == \"uint16\") {\n    if (offset !== undefined) return new Uint16Array(buffer, offset * 2, count);else return new Uint16Array(buffer);\n  } else if (type == \"uint8\") {\n    if (offset !== undefined) return new Uint8Array(buffer, offset, count);else return new Uint8Array(buffer);\n  } else if (type == \"float64\") {\n    if (offset !== undefined) return new Float64Array(buffer, offset * 8, count);else return new Float64Array(buffer);\n  } else if (type == \"float32\") {\n    if (offset !== undefined) return new Float32Array(buffer, offset * 4, count);else return new Float32Array(buffer);\n  } else console.error(\"Unknown array buffer type: \" + type);\n}\n\n// Retrieve an array attribute asynchronously, calling a callback when it's ready ...\nfunction get_model_array_attribute(parameters) {\n  var dfd = $.Deferred();\n  if (parameters.metadata === undefined) {\n    parameters.metadataSuccess = retrieve_model_array_attribute;\n    get_model_array_attribute_metadata(parameters, dfd);\n  } else {\n    retrieve_model_array_attribute(parameters);\n  }\n  return dfd;\n\n  function retrieve_model_array_attribute(parameters) {\n    var ranges = [];\n    var range = '';\n    var metadata = parameters.metadata;\n    var attribute = parameters.attribute;\n    var isStringAttribute = metadata.attributes[attribute].type == \"string\";\n    var byteorder = \"&byteorder=\" + (is_little_endian() ? \"little\" : \"big\");\n    if (isStringAttribute) {\n      byteorder = \"\";\n    }\n\n    for (var dimension in metadata.dimensions) {\n      range = '';\n      range += metadata.dimensions[dimension].begin;\n      range += ':';\n      range += metadata.dimensions[dimension].end;\n      ranges.push(range);\n    }\n    ranges = ranges.join(\"|\");\n\n    var request = new XMLHttpRequest();\n    request.open(\"GET\", parameters.server_root + \"models/\" + parameters.mid + \"/arraysets/\" + parameters.aid + \"/data?hyperchunks=\" + parameters.array + \"/\" + parameters.attribute + \"/\" + ranges + byteorder);\n    if (!isStringAttribute) {\n      request.responseType = \"arraybuffer\";\n    }\n    request.success = parameters.success;\n    request.attribute = parameters.attribute;\n    request.metadata = metadata;\n    request.isStringAttribute = isStringAttribute;\n    request.onload = function (e) {\n      var buffer = this.response;\n      var metadata = this.metadata;\n      var attribute = this.metadata.attributes[this.attribute];\n      var result;\n\n      if (metadata.dimensions.length == 1) {\n        if (!this.isStringAttribute) {\n          result = cast_array_buffer(buffer, attribute.type);\n        } else {\n          result = JSON.parse(this.responseText);\n        }\n      } else if (metadata.dimensions.length == 2) {\n        var row_count = metadata.dimensions[0].end - metadata.dimensions[0].begin;\n        var column_count = metadata.dimensions[1].end - metadata.dimensions[1].begin;\n        var result = [];\n        for (var i = 0; i != row_count; ++i) {\n          result.push(cast_array_buffer(buffer, attribute.type, i * column_count, column_count));\n        }\n      } else {\n        window.alert(\"Can't handle array with \" + metadata.dimensions.length + \" dimensions.\");\n      }\n      this.success(result);\n      dfd.resolve();\n    };\n    request.send();\n  }\n}\n\n// Retrieve an arrayset asynchronously, calling a callback when it's ready ...\nfunction get_model_arrayset(parameters) {\n  if (parameters.metadata !== undefined) {\n    retrieve_model_arrayset(parameters);\n  } else if (arrayset_metadata_cache[parameters.server_root + parameters.mid + parameters.aid] !== undefined) {\n    parameters.metadata = arrayset_metadata_cache[parameters.server_root + parameters.mid + parameters.aid];\n    retrieve_model_arrayset(parameters);\n  } else {\n    parameters.metadataSuccess = retrieve_model_arrayset;\n    get_model_arrayset_metadata(parameters);\n  }\n\n  function retrieve_model_arrayset(parameters) {\n    var metadata = parameters.metadata;\n\n    var arrays = [];\n    var hyperchunks = [];\n\n    if (\"arrays\" in parameters) {\n      for (var i = parseInt(parameters.arrays.split(\":\")[0]); i != parseInt(parameters.arrays.split(\":\")[1]); ++i) {\n        arrays.push(i);\n      }\n      for (var i = 0; i != arrays.length; ++i) {\n        var array = arrays[i];\n        for (var attribute = 0; attribute != metadata[array].attributes.length; ++attribute) {\n          hyperchunks.push(array + \"/\" + attribute + \"/...\");\n        }\n      }\n    } else {\n      hyperchunks.push(\".../.../...\");\n    }\n\n    var uri = parameters.server_root + \"models/\" + parameters.mid + \"/arraysets/\" + parameters.aid + \"/data?byteorder=\" + (is_little_endian() ? \"little\" : \"big\") + \"&hyperchunks=\" + encodeURIComponent(hyperchunks.join(\";\"));\n    var request = new XMLHttpRequest();\n    request.open(\"GET\", uri);\n    request.responseType = \"arraybuffer\";\n    request.success = parameters.success;\n    request.metadata = metadata;\n    request.onload = function (e) {\n      var buffer = this.response;\n      var metadata = this.metadata;\n      var results = [];\n      var result,\n          item,\n          index,\n          count,\n          attributes,\n          attribute = null;\n      var start = 0;\n      var length = metadata.length;\n      if (parameters.arrays !== undefined) {\n        var arrays = parameters.arrays.split(\":\");\n        start = parseInt(arrays[0]);\n        length = parseInt(arrays[1]);\n      }\n      var offset = 0;\n      for (var i = start; i < length; i++) {\n        item = metadata[i];\n        index = item.index;\n        count = item.dimensions[0].end - item.dimensions[0].begin;\n        attributes = item.attributes;\n        result = {};\n        result[\"input-index\"] = index;\n        for (var j = 0; j < attributes.length; j++) {\n          attribute = attributes[j];\n          result[attribute.name] = cast_array_buffer(buffer, attribute.type, offset, count);\n          offset = offset + count;\n        }\n        results.push(result);\n      }\n      this.success(results, metadata, parameters);\n    };\n    request.send();\n  }\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\")))\n\n//# sourceURL=webpack:///./web-server/plugins/slycat-timeseries-model/js/chunker.js?");

/***/ }),

/***/ "./web-server/plugins/slycat-timeseries-model/js/color-switcher.js":
/*!*************************************************************************!*\
  !*** ./web-server/plugins/slycat-timeseries-model/js/color-switcher.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function($) {\n\nvar _d = __webpack_require__(/*! js/d3.min */ \"./web-server/js/d3.min.js\");\n\nvar _d2 = _interopRequireDefault(_d);\n\n__webpack_require__(/*! jquery-ui */ \"./node_modules/jquery-ui/jquery-ui.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/* Copyright (c) 2013, 2018 National Technology and Engineering Solutions of Sandia, LLC . Under the terms of Contract  DE-NA0003525 with National Technology and Engineering Solutions of Sandia, LLC, the U.S. Government  retains certain rights in this software. */\n\n$.widget(\"slycat.colorswitcher\", {\n  options: {\n    colormap: \"day\"\n  },\n\n  _create: function _create() {\n    var self = this;\n\n    this.color_maps = {\n      \"night\": {\n        \"label\": \"Night\",\n        \"background\": _d2.default.rgb(128, 128, 128),\n        \"null_color\": \"rgb(75,75,75)\",\n        \"opacity\": \"0.5\",\n        \"colors\": [_d2.default.rgb(59, 76, 192), _d2.default.rgb(68, 90, 204), _d2.default.rgb(77, 104, 215), _d2.default.rgb(87, 117, 225), _d2.default.rgb(98, 130, 234), _d2.default.rgb(108, 142, 241), _d2.default.rgb(119, 154, 247), _d2.default.rgb(130, 165, 251), _d2.default.rgb(141, 176, 254), _d2.default.rgb(152, 185, 255), _d2.default.rgb(163, 194, 255), _d2.default.rgb(174, 201, 253), _d2.default.rgb(184, 208, 249), _d2.default.rgb(194, 213, 244), _d2.default.rgb(204, 217, 238), _d2.default.rgb(213, 219, 230), _d2.default.rgb(221, 221, 221), _d2.default.rgb(229, 216, 209), _d2.default.rgb(236, 211, 197), _d2.default.rgb(241, 204, 185), _d2.default.rgb(245, 196, 173), _d2.default.rgb(247, 187, 160), _d2.default.rgb(247, 177, 148), _d2.default.rgb(247, 166, 135), _d2.default.rgb(244, 154, 123), _d2.default.rgb(241, 141, 111), _d2.default.rgb(236, 127, 99), _d2.default.rgb(229, 112, 88), _d2.default.rgb(222, 96, 77), _d2.default.rgb(213, 80, 66), _d2.default.rgb(203, 62, 56), _d2.default.rgb(192, 40, 47), _d2.default.rgb(180, 4, 38)]\n      },\n      \"day\": {\n        \"label\": \"Day\",\n        \"background\": _d2.default.rgb(255, 255, 255),\n        \"null_color\": \"gray\",\n        \"opacity\": \"0.7\",\n        \"colors\": [_d2.default.rgb(100, 108, 234), _d2.default.rgb(115, 118, 240), _d2.default.rgb(128, 128, 244), _d2.default.rgb(140, 138, 248), _d2.default.rgb(151, 147, 250), _d2.default.rgb(161, 155, 251), _d2.default.rgb(169, 163, 251), _d2.default.rgb(177, 170, 250), _d2.default.rgb(184, 177, 248), _d2.default.rgb(189, 182, 245), _d2.default.rgb(193, 187, 241), _d2.default.rgb(197, 191, 236), _d2.default.rgb(199, 194, 230), _d2.default.rgb(200, 196, 224), _d2.default.rgb(201, 198, 216), _d2.default.rgb(200, 199, 208), _d2.default.rgb(198, 198, 198), _d2.default.rgb(210, 197, 195), _d2.default.rgb(220, 194, 192), _d2.default.rgb(229, 191, 187), _d2.default.rgb(236, 186, 181), _d2.default.rgb(243, 181, 175), _d2.default.rgb(248, 175, 168), _d2.default.rgb(251, 168, 160), _d2.default.rgb(254, 159, 152), _d2.default.rgb(255, 150, 143), _d2.default.rgb(255, 140, 133), _d2.default.rgb(253, 129, 123), _d2.default.rgb(250, 117, 112), _d2.default.rgb(246, 105, 101), _d2.default.rgb(240, 91, 90), _d2.default.rgb(233, 75, 78), _d2.default.rgb(225, 57, 66)]\n      },\n      \"rainbow\": {\n        \"label\": \"Rainbow Night\",\n        \"background\": _d2.default.rgb(128, 128, 128),\n        \"null_color\": \"rgb(75,75,75)\",\n        \"opacity\": \"0.6\",\n        \"colors\": [_d2.default.rgb(0, 0, 255), _d2.default.rgb(0, 255, 255), _d2.default.rgb(255, 255, 0), _d2.default.rgb(255, 0, 0)]\n      },\n      \"rainbow_day\": {\n        \"label\": \"Rainbow Day\",\n        \"background\": _d2.default.rgb(255, 255, 255),\n        \"null_color\": \"gray\",\n        \"opacity\": \"0.7\",\n        \"colors\": [_d2.default.rgb(0, 0, 255), _d2.default.rgb(0, 255, 255), _d2.default.rgb(255, 255, 0), _d2.default.rgb(255, 0, 0)]\n      }\n    };\n\n    this.button = $('<button class=\"btn btn-xs btn-default dropdown-toggle\" type=\"button\" id=\"colors-dropdown\" data-toggle=\"dropdown\" aria-expanded=\"true\" title=\"Line Color Theme\"> \\\n          Colors \\\n          <span class=\"caret\"></span> \\\n        </button>').appendTo(this.element);\n    this.list = $('<ul class=\"dropdown-menu\" role=\"menu\" aria-labelledby=\"colors-dropdown\">').appendTo(this.element);\n    $.each(this.color_maps, function (key, value) {\n      var gradient_data = self.get_gradient_data(key);\n      var color_stops = [];\n      for (var i = 0; i < gradient_data.length; i++) {\n        color_stops.push(gradient_data[i].color + \" \" + gradient_data[i].offset + \"%\");\n      }\n      var background_color = self.get_background(key);\n      var item = $('<li role=\"presentation\">').addClass(\"color\").toggleClass(\"active\", key == self.options.colormap).attr(\"data-colormap\", key).appendTo(self.list).append($('<a role=\"menuitem\" tabindex=\"-1\">').html(value.label).click(function () {\n        var menu_item = $(this).parent();\n        if (menu_item.hasClass(\"active\")) return false;\n\n        self.options.colormap = menu_item.attr(\"data-colormap\");\n        self.list.find(\".color\").removeClass(\"active\");\n        menu_item.addClass(\"active\");\n\n        self.element.trigger(\"colormap-changed\", [self.options.colormap]);\n      }).css({\n        \"background-image\": \"linear-gradient(to bottom, \" + color_stops.join(\", \") + \"), linear-gradient(to bottom, \" + background_color + \", \" + background_color + \")\",\n        \"background-size\": \"5px 75%, 50px 100%\",\n        \"background-position\": \"right 10px center, right 5px center\",\n        \"background-repeat\": \"no-repeat, no-repeat\",\n        \"padding-right\": \"70px\"\n      }));\n    });\n  },\n\n  _setOption: function _setOption(key, value) {\n    //console.log(\"slycat.colorswitcher._setOption()\", key, value);\n    this.options[key] = value;\n\n    if (key == \"colormap\") {\n      this.list.find(\".color\").removeClass(\"active\");\n      this.list.find(\"[data-colormap='\" + this.options.colormap + \"']\").addClass(\"active\");\n    }\n  },\n\n  // Return a d3 rgb object with the suggested background color for the given color map.\n  get_background: function get_background(name) {\n    if (name === undefined) name = this.options.colormap;\n    return this.color_maps[name].background;\n  },\n\n  // Return the null color value for the given color map.\n  get_null_color: function get_null_color(name) {\n    if (name === undefined) name = this.options.colormap;\n    return this.color_maps[name][\"null_color\"];\n  },\n\n  // Return the suggested opacity value for the given color map.\n  get_opacity: function get_opacity(name) {\n    if (name === undefined) name = this.options.colormap;\n    return this.color_maps[name].opacity;\n  },\n\n  // Return a d3 linear color scale with the current color map for the domain [0, 1].\n  // Callers should modify the domain by passing a min and max to suit their own needs.  \n  get_color_scale: function get_color_scale(name, min, max) {\n    if (name === undefined) name = this.options.colormap;\n    if (min === undefined) min = 0.0;\n    if (max === undefined) max = 1.0;\n    var domain = [];\n    var domain_scale = _d2.default.scale.linear().domain([0, this.color_maps[name].colors.length - 1]).range([min, max]);\n    for (var i in this.color_maps[name].colors) {\n      domain.push(domain_scale(i));\n    }return _d2.default.scale.linear().domain(domain).range(this.color_maps[name].colors);\n  },\n\n  // Deprecated\n  get_color_map: function get_color_map(name, min, max) {\n    return this.get_color_scale(name, min, max);\n  },\n\n  // Return a d3 ordinal color scale with the current color map for the domain [0, 1].\n  // Callers should modify the domain by passing an array of values to suit their own needs. \n  get_color_scale_ordinal: function get_color_scale_ordinal(name, values) {\n    if (name === undefined) name = this.options.colormap;\n    if (values === undefined) values = [0, 1];\n\n    var tempOrdinal = _d2.default.scale.ordinal().domain(values).rangePoints([0, 100], 0);\n    var tempColorscale = this.get_color_scale(name, 0, 100);\n    var rgbRange = [];\n    for (var i = 0; i < values.length; i++) {\n      rgbRange.push(tempColorscale(tempOrdinal(values[i])));\n    }\n    return _d2.default.scale.ordinal().domain(values).range(rgbRange);\n  },\n\n  // Deprecated\n  get_color_map_ordinal: function get_color_map_ordinal(name, values) {\n    return this.get_color_scale_ordinal(name, values);\n  },\n\n  get_gradient_data: function get_gradient_data(name) {\n    var self = this;\n\n    if (name === undefined) name = this.options.colormap;\n\n    var colors = self.color_maps[name][\"colors\"];\n    var length = colors.length;\n    var data = [];\n    for (var i = 0; i < length; i++) {\n      data.push({ offset: i * (100 / (length - 1)), color: colors[length - 1 - i] });\n    }\n    return data;\n  },\n\n  setUpColorMapsForAllColumns: function setUpColorMapsForAllColumns(name, columns) {\n    for (var j = 0; j != columns.length; ++j) {\n      columns[j].colorMap = this.get_color_scale(name, columns[j].columnMin, columns[j].columnMax);\n    }\n  }\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\")))\n\n//# sourceURL=webpack:///./web-server/plugins/slycat-timeseries-model/js/color-switcher.js?");

/***/ }),

/***/ "./web-server/plugins/slycat-timeseries-model/js/timeseries-cluster.js":
/*!*****************************************************************************!*\
  !*** ./web-server/plugins/slycat-timeseries-model/js/timeseries-cluster.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function($) {\n\n__webpack_require__(/*! jquery-ui */ \"./node_modules/jquery-ui/jquery-ui.js\");\n\n$.widget(\"timeseries.cluster\", {\n  options: {\n    clusters: [],\n    cluster: 0\n  },\n\n  _create: function _create() {\n    var self = this;\n\n    this.select_cluster = function (cluster) {\n      this.element.find(\"td.selected\").removeClass(\"selected\");\n      this.element.find(\"td:eq(\" + cluster + \")\").addClass(\"selected\");\n    };\n\n    function click_cluster(context, cluster) {\n      return function () {\n        context.select_cluster(cluster);\n        self.options.cluster = cluster;\n        context.element.trigger(\"cluster-changed\", cluster);\n      };\n    }\n\n    var clusters = this.options.clusters;\n    var cluster = this.options.cluster;\n\n    var row = $(\"<tr>\").appendTo($(\"<thead>\").appendTo(this.element));\n    $(\"<th>\").text(\"Outputs:\").appendTo(row);\n    $.each(clusters, function (index, name) {\n      $(\"<td>\").addClass(\"output\").appendTo(row).data(\"name\", name).data(\"self\", self).data(\"index\", index).text(name).click(click_cluster(self, index));\n    });\n\n    // Setup the default selected cluster ...\n    this.select_cluster(this.options.cluster);\n  }\n\n}); /* Copyright (c) 2013, 2018 National Technology and Engineering Solutions of Sandia, LLC . Under the terms of Contract  DE-NA0003525 with National Technology and Engineering Solutions of Sandia, LLC, the U.S. Government  retains certain rights in this software. */\n\n///////////////////////////////////////////////////////////////////////////////////////////\n// HTML5 DOM cluster control, for use with the timeseries model.\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\")))\n\n//# sourceURL=webpack:///./web-server/plugins/slycat-timeseries-model/js/timeseries-cluster.js?");

/***/ }),

/***/ "./web-server/plugins/slycat-timeseries-model/js/timeseries-controls.js":
/*!******************************************************************************!*\
  !*** ./web-server/plugins/slycat-timeseries-model/js/timeseries-controls.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function($) {\n\nvar _slycatServerRoot = __webpack_require__(/*! js/slycat-server-root */ \"./web-server/js/slycat-server-root.js\");\n\nvar _slycatServerRoot2 = _interopRequireDefault(_slycatServerRoot);\n\nvar _slycatDialogWebpack = __webpack_require__(/*! js/slycat-dialog-webpack */ \"./web-server/js/slycat-dialog-webpack.js\");\n\nvar dialog = _interopRequireWildcard(_slycatDialogWebpack);\n\nvar _lodash = __webpack_require__(/*! lodash */ \"./node_modules/lodash/lodash.js\");\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _papaparse = __webpack_require__(/*! papaparse */ \"./node_modules/papaparse/papaparse.js\");\n\nvar _papaparse2 = _interopRequireDefault(_papaparse);\n\n__webpack_require__(/*! jquery-ui */ \"./node_modules/jquery-ui/jquery-ui.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } /* Copyright (c) 2013, 2018 National Technology and Engineering Solutions of Sandia, LLC . Under the terms of Contract  DE-NA0003525 with National Technology and Engineering Solutions of Sandia, LLC, the U.S. Government  retains certain rights in this software. */\n\n$.widget(\"timeseries.controls\", {\n  options: {\n    mid: null,\n    model_name: null,\n    aid: null,\n    metadata: null,\n    // cluster_index : null,\n    \"color-variable\": null,\n    clusters: [],\n    cluster: null,\n    color_variables: [],\n    selection: [],\n    hidden_simulations: [],\n    indices: [],\n    highlight: []\n  },\n\n  _create: function _create() {\n    var self = this;\n    var general_controls = $(\"#general-controls\", this.element);\n\n    this.color_control = $('<div class=\"btn-group btn-group-xs\"></div>').appendTo(general_controls);\n    this.color_button = $('\\\n      <button class=\"btn btn-default dropdown-toggle\" type=\"button\" id=\"color-dropdown\" data-toggle=\"dropdown\" aria-expanded=\"true\" title=\"Change Line Color\"> \\\n        Line Color \\\n        <span class=\"caret\"></span> \\\n      </button> \\\n      ').appendTo(self.color_control);\n    this.color_items = $('<ul id=\"y-axis-switcher\" class=\"dropdown-menu\" role=\"menu\" aria-labelledby=\"color-dropdown\">').appendTo(self.color_control);\n\n    this.csv_button = $(\"\\\n      <button class='btn btn-default' title='Download Data Table'> \\\n        <span class='fa fa-download' aria-hidden='true'></span> \\\n      </button> \\\n      \").click(function () {\n      if (self.options.highlight.length == 0 && (self.options.selection == null || self.options.selection.length == self.options.metadata['row-count'])) {\n        self._write_data_table();\n      } else {\n        openCSVSaveChoiceDialog();\n      }\n    }).appendTo(general_controls);\n\n    function openCSVSaveChoiceDialog() {\n      var txt = \"\";\n      var buttons_save = [{ className: \"btn-default\", label: \"Cancel\" }, { className: \"btn-primary\", label: \"Save Entire Table\", icon_class: \"fa fa-table\" }];\n      var filteredHighlight;\n      if (self.options.selection != null && self.options.selection.length > 0) {\n        filteredHighlight = self.options.highlight.filter(function (el) {\n          return self.options.selection.indexOf(el) != -1;\n        });\n      } else {\n        filteredHighlight = self.options.highlight;\n      }\n\n      if (filteredHighlight.length > 0) {\n        // txt += \"You have \" + filteredHighlight.length + \" rows selected. \";\n        txt += \"You have \" + filteredHighlight.length + \" rows selected. \";\n        buttons_save.splice(buttons_save.length - 1, 0, { className: \"btn-primary\", label: \"Save Selected\", icon_class: \"fa fa-check\" });\n      }\n      if (self.options.selection != null && self.options.selection.length > 0 && self.options.selection.length < self.options.metadata['row-count']) {\n        var visibleRows = self.options.selection.length;\n        txt += \"You have \" + visibleRows + \" rows visible. \";\n        buttons_save.splice(buttons_save.length - 1, 0, { className: \"btn-primary\", label: \"Save Visible\", icon_class: \"fa fa-eye\" });\n      }\n\n      txt += \"What would you like to do?\";\n\n      dialog.dialog({\n        title: \"Download Choices\",\n        message: txt,\n        buttons: buttons_save,\n        callback: function callback(button) {\n          if (button.label == \"Save Entire Table\") self._write_data_table();else if (button.label == \"Save Selected\") self._write_data_table(filteredHighlight);else if (button.label == \"Save Visible\") self._write_data_table(self.options.selection);\n        }\n      });\n    }\n\n    // if(self.options.clusters.length > 0)\n    // {\n    //   self._set_clusters();\n    // }\n    self._set_color_variables();\n  },\n\n  _write_data_table: function _write_data_table(selectionList) {\n    var self = this;\n    $.ajax({\n      type: \"POST\",\n      url: _slycatServerRoot2.default + \"models/\" + self.options.mid + \"/arraysets/\" + self.options.aid + \"/data\",\n      data: JSON.stringify({ \"hyperchunks\": \"0/.../...\" }),\n      contentType: \"application/json\",\n      success: function success(result) {\n        self._write_csv(self._convert_to_csv(result, selectionList), self.options.model_name + \"_data_table.csv\");\n      },\n      error: function error(request, status, reason_phrase) {\n        window.alert(\"Error retrieving data table: \" + reason_phrase);\n      }\n    });\n  },\n\n  _write_csv: function _write_csv(csvData, defaultFilename) {\n    var blob = new Blob([csvData], {\n      type: \"application/csv;charset=utf-8;\"\n    });\n    var csvUrl = URL.createObjectURL(blob);\n    var link = document.createElement(\"a\");\n    link.href = csvUrl;\n    link.style = \"visibility:hidden\";\n    link.download = defaultFilename || \"slycatDataTable.csv\";\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n  },\n\n  _convert_to_csv: function _convert_to_csv(array, sl) {\n    // Note that array.data is column-major:  array.data[0][*] is the first column\n    var self = this;\n\n    // Converting data array from column major to row major\n    var rowMajorData = _lodash2.default.zip.apply(_lodash2.default, _toConsumableArray(array));\n\n    // If we have a selection list, remove everything but those elements from the data array\n    if (sl != undefined && sl.length > 0) {\n      // sl is in the order the user selected the rows, so sort it.\n      // We want to end up with rows in the same order as in the original data.\n      sl.sort();\n      // Only keep elements at the indexes specified in sl\n      rowMajorData = _lodash2.default.at(rowMajorData, sl);\n    }\n\n    // Creating an array of column headers by removing the last one, which is the Index that does not exist in the data\n    var headers = self.options.metadata[\"column-names\"].slice(0, -1);\n    // Adding headers as first element in array of data rows\n    rowMajorData.unshift(headers);\n\n    // Creating CSV from data array\n    var csv = _papaparse2.default.unparse(rowMajorData);\n    return csv;\n  },\n\n  _set_color_variables: function _set_color_variables() {\n    var self = this;\n    this.color_items.empty();\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = this.options.color_variables[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var value = _step.value;\n\n        $(\"<li role='presentation'>\").toggleClass(\"active\", self.options[\"color-variable\"] == value).attr(\"data-colorvariable\", value).appendTo(self.color_items).append($('<a role=\"menuitem\" tabindex=\"-1\">').html(this.options.metadata['column-names'][value]).click(function () {\n          var menu_item = $(this).parent();\n          if (menu_item.hasClass(\"active\")) return false;\n\n          self.color_items.find(\"li\").removeClass(\"active\");\n          menu_item.addClass(\"active\");\n\n          self.element.trigger(\"color-selection-changed\", menu_item.attr(\"data-colorvariable\"));\n        }));\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  },\n\n  _set_selected_color: function _set_selected_color() {\n    var self = this;\n    self.color_items.find(\"li\").removeClass(\"active\");\n    self.color_items.find('li[data-colorvariable=\"' + self.options[\"color-variable\"] + '\"]').addClass(\"active\");\n  },\n\n  // Clones an ArrayBuffer or Array\n  _cloneArrayBuffer: function _cloneArrayBuffer(source) {\n    // Array.apply method of turning an ArrayBuffer into a normal array is very fast (around 5ms for 250K) but doesn't work in WebKit with arrays longer than about 125K\n    // if(source.length > 1)\n    // {\n    //   return Array.apply( [], source );\n    // }\n    // else if(source.length == 1)\n    // {\n    //   return [source[0]];\n    // }\n    // return [];\n\n    // For loop method is much shower (around 300ms for 250K) but works in WebKit. Might be able to speed things up by using ArrayBuffer.subarray() method to make smallery arrays and then Array.apply those.\n    var clone = [];\n    for (var i = 0; i < source.length; i++) {\n      clone.push(source[i]);\n    }\n    return clone;\n  },\n\n  _setOption: function _setOption(key, value) {\n    var self = this;\n\n    this.options[key] = value;\n\n    if (key == \"color-variable\") {\n      self._set_selected_color();\n    } else if (key == 'color_variables') {\n      self._set_color_variables();\n    }\n  }\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\")))\n\n//# sourceURL=webpack:///./web-server/plugins/slycat-timeseries-model/js/timeseries-controls.js?");

/***/ }),

/***/ "./web-server/plugins/slycat-timeseries-model/js/timeseries-dendrogram.js":
/*!********************************************************************************!*\
  !*** ./web-server/plugins/slycat-timeseries-model/js/timeseries-dendrogram.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function($) {\n\nvar _d = __webpack_require__(/*! js/d3.min */ \"./web-server/js/d3.min.js\");\n\nvar _d2 = _interopRequireDefault(_d);\n\nvar _chunker = __webpack_require__(/*! ./chunker */ \"./web-server/plugins/slycat-timeseries-model/js/chunker.js\");\n\nvar chunker = _interopRequireWildcard(_chunker);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/* Copyright (c) 2013, 2018 National Technology and Engineering Solutions of Sandia, LLC . Under the terms of Contract  DE-NA0003525 with National Technology and Engineering Solutions of Sandia, LLC, the U.S. Government  retains certain rights in this software. */\n\n///////////////////////////////////////////////////////////////////////////////////////////\n// HTML5 DOM dendrogram control, for use with the timeseries model.\n\n$.widget(\"timeseries.dendrogram\", {\n  options: {\n    \"server-root\": \"\",\n    mid: null,\n    clusters: [],\n    cluster: 0,\n    cluster_data: null,\n    collapsed_nodes: null,\n    expanded_nodes: null,\n    selected_nodes: null,\n    color_array: null,\n    color_scale: null,\n    data_table_index_array: null,\n    dendrogram_sort_order: true,\n    highlight: [],\n    image_columns: []\n  },\n\n  _create: function _create() {\n    this._set_cluster();\n  },\n\n  _set_cluster: function _set_cluster() {\n    var self = this;\n    self.container = _d2.default.select(\"#dendrogram-viewer\");\n\n    var cluster_data = this.options.cluster_data;\n    var collapsed_nodes = this.options.collapsed_nodes;\n    var expanded_nodes = this.options.expanded_nodes;\n    var selected_nodes = this.options.selected_nodes;\n    var server_root = self.options[\"server-root\"];\n    var mid = self.options.mid;\n\n    var linkage = cluster_data[\"linkage\"];\n    var input_indices = cluster_data[\"input-indices\"];\n    var exemplars = cluster_data[\"exemplars\"];\n    var subtrees = [];\n\n    for (var i = 0; i < input_indices.length; i++) {\n      subtrees.push({ \"node-index\": subtrees.length, leaves: 1, exemplar: exemplars[i], selected: false, \"waveform-index\": i, \"data-table-index\": input_indices[i] });\n    }\n    for (var i = 0; i < linkage.length; i++) {\n      subtrees.push({ \"node-index\": subtrees.length, children: [subtrees[linkage[i][0]], subtrees[linkage[i][1]]], leaves: linkage[i][3], exemplar: exemplars[i + input_indices.length], selected: false, \"waveform-index\": null, \"data-table-index\": null });\n    }\n\n    var padding = 20;\n    var diagram_width = this.element.parent().width() - padding - padding - 110;\n    var diagram_height = this.element.parent().height() - padding - padding;\n\n    var layout = _d2.default.layout.cluster().size([diagram_height, diagram_width]) // Width and height are transposed here because the layout defaults top-to-buttom.\n    .separation(function () {\n      return 1;\n    });\n\n    self.container.selectAll(\"g\").remove();\n\n    self.sortControl = $('<div id=\"dendrogram-sort-control\"></div>').appendTo('#dendrogram-pane').click(function () {\n      if (!$(this).hasClass(\"selected\")) {\n        self.options.dendrogram_sort_order = true;\n        self._set_dendrogram_sort_order_state();\n        self.element.trigger(\"sort-by-dendrogram-order\");\n      }\n    });\n\n    self.outputsButtonLabel = $('#dendrogram-controls button.outputs .buttonLabel');\n    self.outputs_items = $('#dendrogram-controls ul.outputs');\n\n    self._set_dendrogram_sort_order_state();\n    self._set_outputs();\n\n    var vis = self.container.append(\"svg:g\").attr(\"transform\", \"translate(\" + padding + \",\" + padding + \")\");\n\n    var root = subtrees[subtrees.length - 1];\n    self.root = root;\n    root.x0 = diagram_height / 2;\n    root.y0 = 0;\n\n    // Compute the layout once for the entire tree so we can capture the max depth ...\n    var nodes = layout.nodes(root).reverse();\n    var max_depth = -1;\n    nodes.forEach(function (d) {\n      max_depth = Math.max(max_depth, d.depth);\n    });\n\n    // We have collapse/expand/selected node data. Let's go ahead and apply it.\n    if (collapsed_nodes != null || expanded_nodes != null || selected_nodes != null) {\n      nodes.forEach(function (d) {\n        if (selected_nodes != null && selected_nodes.length > 0) {\n          if (selected_nodes.indexOf(d[\"node-index\"]) > -1) {\n            d.selected = true;\n          }\n        }\n        if (collapsed_nodes && collapsed_nodes.indexOf(d[\"node-index\"]) > -1 && d.children) {\n          toggle(d);\n        } else if (expanded_nodes && expanded_nodes.indexOf(d[\"node-index\"]) > -1 && d._children) {\n          toggle(d);\n        }\n      });\n    }\n    // We have no data on expanded / collapsed nodes. Let's go ahead and just show the top four levels.\n    if (expanded_nodes == null && collapsed_nodes == null) {\n      // Start showing the top four levels of the tree ...\n      nodes.forEach(function (d) {\n        if (d.depth == 3) toggle(d);\n      });\n    }\n    // We have no selected node data. Let's select the root node.\n    if (selected_nodes == null) {\n      select_node(self, root, true);\n    } else {\n      // We had selected node data, so let's style them and trigger the node-selection-changed event\n      style_selected_nodes();\n      color_links();\n      // Find all selected nodes\n      var selection = [];\n      find_selected_nodes(root, selection);\n      self.element.trigger(\"node-selection-changed\", { node: null, skip_bookmarking: true, selection: selection });\n    }\n\n    // Initial update for the diagram ...\n    update_subtree(root, true);\n\n    function getNodeIndexes(nodes) {\n      var node_indexes = [];\n      var node_index = null;\n\n      for (var i = 0; i < nodes.length; i++) {\n        node_index = nodes[i][\"node-index\"];\n        if (node_index != null) node_indexes.push(node_index);\n      }\n\n      return node_indexes;\n    }\n\n    // Helper function that draws dendrogram links with right-angles.\n    function path(d, i) {\n      if (d.target._children) {\n        return \"M\" + d.source.y + \",\" + d.source.x + \"V\" + d.target.x + \"H\" + diagram_width;\n      }\n      return \"M\" + d.source.y + \",\" + d.source.x + \"V\" + d.target.x + \"H\" + d.target.y;\n    }\n\n    function find_selected_nodes(d, selection) {\n      if (d.selected) selection.push({ \"node-index\": d[\"node-index\"], \"waveform-index\": d[\"waveform-index\"], \"data-table-index\": d[\"data-table-index\"] });\n      if (d.children) for (var i = 0; i < d.children.length; i++) {\n        find_selected_nodes(d.children[i], selection);\n      }if (d._children) for (var i = 0; i < d._children.length; i++) {\n        find_selected_nodes(d._children[i], selection);\n      }\n    }\n\n    // Keeping track of already selected nodes becomes too complicated with multi selection\n    //var last_selected_node = null;\n    function select_node(context, d, skip_bookmarking) {\n      // Keeping track of already selected nodes becomes too complicated with multi selection\n      // if(last_selected_node === d)\n      //   return;\n      // last_selected_node = d;\n\n      function select_subtree(d) {\n        d.selected = true;\n        if (d.children) for (var i = 0; i < d.children.length; i++) {\n          select_subtree(d.children[i]);\n        }if (d._children) for (var i = 0; i < d._children.length; i++) {\n          select_subtree(d._children[i]);\n        }\n      }\n\n      // Mark this node and all its children as selected\n      select_subtree(d);\n\n      // Sets the \"selected\" class on all selected nodes, thus coloring the circles in blue\n      style_selected_nodes();\n\n      // Colors the lines between the nodes to show what's selected\n      color_links();\n\n      // Find all selected nodes\n      var selection = [];\n      find_selected_nodes(root, selection);\n      context.options.selected_nodes = getNodeIndexes(selection);\n\n      context.element.trigger(\"node-selection-changed\", { node: d, skip_bookmarking: skip_bookmarking, selection: selection });\n    }\n\n    function unselect_node(context, d, skip_bookmarking) {\n      function unselect_subtree(d) {\n        d.selected = false;\n        if (d.children) for (var i = 0; i < d.children.length; i++) {\n          unselect_subtree(d.children[i]);\n        }if (d._children) for (var i = 0; i < d._children.length; i++) {\n          unselect_subtree(d._children[i]);\n        }\n      }\n\n      // Mark this node and all its children as unselected\n      unselect_subtree(d);\n\n      // Prunes selected nodes that have been orphaned\n      prune_tree(root);\n\n      // Sets the \"selected\" class on all selected nodes, thus coloring the circles in blue\n      style_selected_nodes();\n\n      // Colors the lines between the nodes to show what's selected\n      color_links();\n\n      // Find all selected nodes\n      var selection = [];\n      find_selected_nodes(root, selection);\n      context.options.selected_nodes = getNodeIndexes(selection);\n\n      context.element.trigger(\"node-selection-changed\", { node: d, skip_bookmarking: skip_bookmarking, selection: selection });\n    }\n\n    function style_selected_nodes() {\n      self.container.selectAll(\".node\").classed(\"selected\", function (d) {\n        return d.selected;\n      });\n    }\n\n    function color_links() {\n      self.container.selectAll(\"path.link\").attr(\"style\", function (d) {\n        if (checkChildren(d.target)) {\n          if (d.source.selected) return \"stroke: black;\";else return \"stroke: #646464;\";\n        }\n      });\n\n      // Checks if target or any of its children are selected\n      function checkChildren(target) {\n        if (target.selected) return true;else if (target.children) {\n          for (var i = 0; i < target.children.length; i++) {\n            if (checkChildren(target.children[i])) return true;\n          }\n        } else if (target._children) {\n          for (var i = 0; i < target._children.length; i++) {\n            if (checkChildren(target._children[i])) return true;\n          }\n        }\n        return false;\n      }\n    }\n\n    function prune_tree(d) {\n      if (d.children || d._children) {\n        // This is a branch node\n        if (!d.selected) {\n          // Branch node is unselected, so just process its children\n          if (d.children) $.each(d.children, function (index, subtree) {\n            prune_tree(subtree);\n          });\n          if (d._children) $.each(d._children, function (index, subtree) {\n            prune_tree(subtree);\n          });\n          return false;\n        } else {\n          //Branch node is selected, so process its children and set its selected state accordingly\n          var selected_state = false;\n          var child_selected_state = false;\n          if (d.children) $.each(d.children, function (index, subtree) {\n            child_selected_state = prune_tree(subtree);\n            selected_state = selected_state || child_selected_state;\n          });\n          if (d._children) $.each(d._children, function (index, subtree) {\n            child_selected_state = prune_tree(subtree);\n            selected_state = selected_state || child_selected_state;\n          });\n          d.selected = selected_state;\n          return selected_state;\n        }\n      } else {\n        // This is a leaf node\n        if (d.selected) return true;else return false;\n      }\n    }\n\n    function update_subtree(source, skip_bookmarking) {\n      var duration = _d2.default.event && _d2.default.event.altKey ? 5000 : 500;\n\n      // Compute the new layout.\n      var nodes = layout.nodes(root).reverse();\n\n      // Compute the currend dendrogram depth\n      var current_depth = -1;\n      nodes.forEach(function (d) {\n        current_depth = Math.max(current_depth, d.children ? d.depth : -1);\n      });\n\n      // Normalize for current depth.\n      nodes.forEach(function (d) {\n        if (d.children || d._children) {\n          d.y = d.depth * (diagram_width / (current_depth + 1));\n        }\n      });\n\n      // Update the nodes.\n      var node = vis.selectAll(\"g.node\").data(nodes, function (d) {\n        return d[\"node-index\"];\n      });\n\n      // Expand all child nodes up to a certain level, collapse all child when level is rached\n      function expandUpToLevel(d, level) {\n        if (d.children) {\n          for (var i = 0; i < d.children.length; i++) {\n            // If this child is at the correct depth and it is expanded, we collapse it\n            if (d.children[i].depth == level && d.children[i].children) {\n              toggle(d.children[i]);\n            }\n            // If this child is above the correct depth and it is collapsed, we expand it and process its children\n            else if (d.children[i].depth < level && d.children[i]._children) {\n                toggle(d.children[i]);\n                expandUpToLevel(d.children[i], level);\n              }\n              // If this child is above the correct depth and it is expanded, we just process its children\n              else if (d.children[i].depth < level && d.children[i].children) {\n                  expandUpToLevel(d.children[i], level);\n                }\n          }\n        }\n        // If d has no children, we do nothing\n        else {\n            return;\n          }\n      }\n\n      // Create new nodes at the parent's previous position.\n      var node_enter = node.enter().append(\"svg:g\").attr(\"class\", \"node\").classed(\"selected\", function (d) {\n        return d.selected;\n      }).attr(\"transform\", function (d) {\n        return \"translate(\" + source.y0 + \",\" + source.x0 + \")\";\n      }).style(\"opacity\", 1e-6);\n\n      // Triangle\n      var node_subtree = node_enter.append(\"svg:g\").attr(\"class\", \"subtree\").style(\"opacity\", 1e-6).style(\"display\", function (d) {\n        return d.leaves > 1 ? \"inline\" : \"none\";\n      }).on(\"click\", function (d) {\n        toggle(d);\n        // Change expandThisFar to however deep below the target node you want to expand\n        var expandThisFar = 9999;\n        expandUpToLevel(d, d.depth + expandThisFar);\n        update_subtree(d);\n      });\n\n      node_subtree.append(\"svg:path\").attr(\"class\", \"subtree-glyph\").attr(\"title\", \"Expand all\").attr(\"alt\", \"Expand all\").attr(\"d\", \"M 0 0 L 40 -13 L 40 13 Z\").style(\"fill\", \"url(#subtree-gradient)\");\n\n      // Due to a bug in Firefox, we cannot use css to change the fill style on path.subtree-glyph from above.\n      // Instead we'll use css to display and hide this path.filled-glyph\n      node_subtree.append(\"svg:path\").attr(\"class\", \"filled-glyph\").attr(\"title\", \"Expand all\").attr(\"alt\", \"Expand all\").attr(\"d\", \"M 0 0 L 40 -13 L 40 13 Z\").style(\"fill\", \"#7767b0\");\n\n      node_subtree.append(\"svg:text\").attr(\"x\", 28).attr(\"dy\", \".4em\").attr(\"text-anchor\", \"middle\").attr(\"title\", \"Expand all\").attr(\"alt\", \"Expand all\").text(function (d) {\n        return d.leaves;\n      });\n\n      node_subtree.append(\"svg:text\").attr(\"x\", -9).attr(\"dy\", -5).attr(\"text-anchor\", \"middle\").text(\"+\").style(\"fill\", \"black\").on(\"click\", function (d) {\n        toggle(d);\n        // Change expandThisFar to however deep below the target node you want to expand\n        var expandThisFar = 2;\n        expandUpToLevel(d, d.depth + expandThisFar);\n        update_subtree(d);\n        _d2.default.event.stopPropagation();\n      });\n\n      // Circle\n      var node_glyph = node_enter.append(\"svg:g\").attr(\"class\", \"glyph\").on(\"click\", function (d) {\n        if (_d2.default.event.ctrlKey || _d2.default.event.metaKey) {\n          if (d.selected) {\n            unselect_node(self, d);\n          } else {\n            select_node(self, d);\n          }\n        } else {\n          // Clear previous selection if user didn't Ctrl+click\n          $.each(subtrees, function (index, subtree) {\n            subtree.selected = false;\n          });\n          select_node(self, d);\n        }\n      });\n\n      node_glyph.append(\"svg:circle\").attr(\"r\", 4.5).style(\"cursor\", \"pointer\").style(\"fill\", function (d) {\n        return d.children || d._children ? \"#dbd9eb\" : \"white\";\n      });\n\n      node_glyph.append(\"svg:text\").attr(\"x\", -9).attr(\"dy\", 13).attr(\"text-anchor\", \"middle\").text(\"\").style(\"fill\", \"black\").style(\"display\", function (d) {\n        return d._children || !d.children && !d._children ? \"none\" : \"inline\";\n      }).on(\"click\", function (d) {\n        toggle(d);\n        update_subtree(d);\n        _d2.default.event.stopPropagation();\n      });\n\n      // Sparkline\n      var node_sparkline = node_enter.append(\"svg:g\").attr(\"class\", \"sparkline\").attr(\"transform\", function (d) {\n        return d.leaves > 1 ? \"translate(55, 0)\" : \"translate(15, 0)\";\n      }) // Move sparkline to the right according to whether it's an endpoint\n      .style(\"opacity\", 1e-6).style(\"display\", \"none\");\n\n      var node_sparkline_path = node_sparkline.append(\"svg:path\")\n      // Can't set attr here because we download waveforms asynchronously. Instead doing this below.\n      //.attr(\"d\", sparkline)\n      .style(\"stroke\", function (d, i) {\n        if (self.options.color_scale !== null && self.options.color_array != null) {\n          var index = d[\"data-table-index\"];\n          if (index != null) {\n            var value = self.options.color_array[index];\n            if (value != null) return self.options.color_scale(value);else return $(\"#color-switcher\").colorswitcher(\"get_null_color\");\n          } else return \"black\";\n        } else {\n          return \"black\";\n        }\n      }).classed(\"nullValue\", function (d, i) {\n        return !(d[\"data-table-index\"] == null || d[\"data-table-index\"] != null && self.options.color_array[d[\"data-table-index\"]] !== null);\n      }).on(\"click\", function (d) {\n        self._handle_highlight(d, _d2.default.event, this);\n      });\n      self._set_highlight();\n\n      function s_to_a(s) {\n        if (Array.isArray(s)) return s;else return JSON.parse(s);\n      }\n\n      chunker.get_model_arrayset_metadata({\n        server_root: self.options[\"server-root\"],\n        mid: self.options.mid,\n        aid: \"preview-\" + s_to_a(self.options.clusters)[self.options.cluster],\n        success: function success(parameters) {\n          node_sparkline_path.each(function (d, i) {\n            if (d.exemplar == undefined) {\n              $(this).attr(\"d\", \"\");\n            } else {\n              chunker.get_model_arrayset({\n                server_root: self.options[\"server-root\"],\n                mid: self.options.mid,\n                aid: \"preview-\" + s_to_a(self.options.clusters)[self.options.cluster],\n                arrays: d[\"exemplar\"] + \":\" + (d[\"exemplar\"] + 1),\n                element: this,\n                success: function success(result, metadata, parameters) {\n                  var values = result[0][\"value\"];\n                  var data = [];\n                  for (var i = 0; i != values.length; ++i) {\n                    data.push(values[i]);\n                  }\n\n                  var width = 100;\n                  var height = 15;\n                  var min = _d2.default.min(data);\n                  var max = _d2.default.max(data);\n                  var x = _d2.default.scale.linear().domain([0, data.length - 1]).range([0, width]);\n                  var y = _d2.default.scale.linear().domain([max, min]).range([-height, height]).nice();\n\n                  var path = _d2.default.svg.line().x(function (d, i) {\n                    return x(i);\n                  }).y(function (d) {\n                    return y(d);\n                  });\n\n                  $(parameters.element).attr(\"d\", path(data));\n                  //$(parameters.element).attr(\"d\", \"M 0 0 L 50 0 L 100 -5\");\n                }\n              });\n            }\n          });\n        }\n      });\n      // Set the d attribute of each sparkline path. Currently doing this by downloading each waveform individually. In the future we might want to batch it up.\n\n\n      // If we ever get the ability to download arbitrary batches of waveforms using \"GET Model Arrayset\", this is a stub-out for doing so\n      // function getWaveforms(selection){\n      //   console.log(selection);\n      //   selection.each(function(d,i){\n      //     console.log(\"exemplar is \" + d.exemplar);\n      //   });\n      // }\n      // node_enter.call(getWaveforms);\n\n      // Transition new nodes to their final position.\n      var node_update = node.transition().duration(duration).attr(\"transform\", function (d) {\n        return \"translate(\" + (d._children ? diagram_width - 40 : d.y) + \",\" + d.x + \")\"; // Draws extended horizontal lines for collapsed nodes\n      }).style(\"opacity\", 1.0);\n\n      node_update.select(\".subtree\").style(\"opacity\", function (d) {\n        return d._children ? 1.0 : 1e-6;\n      }).style(\"display\", function (d) {\n        return d._children ? \"inline\" : \"none\";\n      });\n\n      // Need to re-assign fill style to get around this firefox bug: https://bugzilla.mozilla.org/show_bug.cgi?id=652991\n      // It only seems to affect fill gradients and only when the URI changes, like it does for us with bookmarking.\n      node_update.select(\".subtree-glyph\").style(\"fill\", \"url(#subtree-gradient)\");\n\n      node_update.select(\".sparkline\").style(\"opacity\", function (d) {\n        return d._children || !d.children && !d._children ? 1.0 : 1e-6;\n      }).each(\"end\", function () {\n        _d2.default.select(this).style(\"display\", function (d) {\n          return d._children || !d.children && !d._children ? \"inline\" : \"none\";\n        });\n      });\n\n      node_update.select(\".glyph text\").style(\"display\", function (d) {\n        return d._children || !d.children && !d._children ? \"none\" : \"inline\";\n      });\n\n      // Transition exiting nodes to the parent's new position.\n      var node_exit = node.exit().transition().duration(duration).attr(\"transform\", function (d) {\n        return \"translate(\" + source.y + \",\" + source.x + \")\";\n      }).style(\"opacity\", 1e-6).remove();\n\n      node_exit.select(\".sparkline\").each(\"start\", function () {\n        _d2.default.select(this).style(\"display\", \"none\");\n      });\n\n      // Update the links.\n      var link = vis.selectAll(\"path.link\").data(layout.links(nodes), function (d) {\n        return d.target[\"node-index\"];\n      });\n\n      // Enter any new links at the parent's previous position.\n      link.enter().insert(\"svg:path\", \"g\").attr(\"class\", \"link\").attr(\"d\", function (d) {\n        var o = { x: source.x0, y: source.y0 };\n        return path({ source: o, target: o });\n      }).transition().duration(duration).attr(\"d\", path);\n\n      // Transition new links to their new position.\n      link.transition().duration(duration).attr(\"d\", path);\n\n      // Transition exiting links to the parent's new position.\n      link.exit().transition().duration(duration).attr(\"d\", function (d) {\n        var o = { x: source.x, y: source.y };\n        return path({ source: o, target: o });\n      }).remove();\n\n      color_links();\n\n      // Stash the old positions for transition.\n      nodes.forEach(function (d) {\n        d.x0 = d.x;\n        d.y0 = d.y;\n      });\n\n      // Bookmark expanded and collapsed nodes\n      if (!skip_bookmarking) {\n        var findExpandedAndCollapsedNodes = function findExpandedAndCollapsedNodes(d) {\n          // If this node is expanded, add its node-index to the expanded array\n          if (d.children) {\n            expanded.push(d[\"node-index\"]);\n            // Recursively call this function for each child to capture any collapsed and expanded ones\n            for (var i = 0; i < d.children.length; i++) {\n              findExpandedAndCollapsedNodes(d.children[i]);\n            }\n          }\n          // Otherwise if this node is collapsed, add its node-index to the collapsed array\n          else if (d._children) {\n              collapsed.push(d[\"node-index\"]);\n            }\n        };\n\n        var expanded = [];\n        var collapsed = [];\n\n        findExpandedAndCollapsedNodes(root);\n        self.options.expanded_nodes = expanded;\n        self.options.collapsed_nodes = collapsed;\n        self.element.trigger(\"expanded-collapsed-nodes-changed\", { expanded: expanded, collapsed: collapsed });\n      }\n    }\n\n    // Toggle children.\n    function toggle(d) {\n      if (d.children) {\n        d._children = d.children;\n        d.children = null;\n      } else {\n        d.children = d._children;\n        d._children = null;\n      }\n\n      self.element.trigger(\"node-toggled\", d);\n    }\n  },\n\n  _set_color: function _set_color() {\n    var self = this;\n\n    this.container.selectAll(\"g.sparkline path\").style(\"stroke\", function (d, i) {\n      var index = d[\"data-table-index\"];\n      if (index != null) {\n        var value = self.options.color_array[index];\n        if (value != null) return self.options.color_scale(value);else return $(\"#color-switcher\").colorswitcher(\"get_null_color\");\n      } else return \"black\";\n    }).classed(\"nullValue\", function (d, i) {\n      if (d[\"data-table-index\"] == null || d[\"data-table-index\"] != null && self.options.color_array[d[\"data-table-index\"]] !== null) return false;else return true;\n    });\n  },\n\n  _set_highlight: function _set_highlight() {\n    var self = this;\n\n    checkChildren(self.root);\n\n    this.container.selectAll(\"g.sparkline path\").classed(\"highlight\", function (d, i) {\n      if (d.highlight) return true;else return false;\n    });\n\n    // Checks if target or any of its children are highlighted\n    function checkChildren(target) {\n      var highlight = false;\n      if (target.children) {\n        for (var i = 0; i < target.children.length; i++) {\n          if (checkChildren(target.children[i])) {\n            highlight = true;\n          }\n        }\n        target.highlight = highlight;\n      } else if (target._children) {\n        for (var i = 0; i < target._children.length; i++) {\n          if (checkChildren(target._children[i])) {\n            highlight = true;\n          }\n        }\n        target.highlight = highlight;\n      } else if (target[\"data-table-index\"] != null && self.options.highlight.indexOf(target[\"data-table-index\"]) > -1) {\n        target.highlight = true;\n        highlight = true;\n      } else {\n        target.highlight = false;\n        highlight = false;\n      }\n      return highlight;\n    }\n  },\n\n  _handle_highlight: function _handle_highlight(d, event, element) {\n    var self = this;\n    var data_table_indexes = getDataTableIndexesFromChildren(d);\n\n    if (!event.ctrlKey && !event.metaKey) {\n      self.options.highlight = data_table_indexes;\n    } else {\n      if (d.highlight) {\n        for (var i = 0; i < data_table_indexes.length; i++) {\n          var index = self.options.highlight.indexOf(data_table_indexes[i]);\n          if (index > -1) {\n            self.options.highlight.splice(index, 1);\n          }\n        }\n      } else {\n        for (var i = 0; i < data_table_indexes.length; i++) {\n          if (self.options.highlight.indexOf(data_table_indexes[i]) == -1) self.options.highlight.push(data_table_indexes[i]);\n        }\n      }\n    }\n    self._set_highlight();\n    self.element.trigger(\"waveform-selection-changed\", [self.options.highlight]);\n\n    function getDataTableIndexesFromChildren(target) {\n      var data_table_indexes = [];\n      if (target.children) {\n        for (var i = 0; i < target.children.length; i++) {\n          if (target.children[i][\"data-table-index\"] != null) data_table_indexes.push(target.children[i][\"data-table-index\"]);else data_table_indexes = data_table_indexes.concat(getDataTableIndexesFromChildren(target.children[i]));\n        }\n      } else if (target._children) {\n        for (var i = 0; i < target._children.length; i++) {\n          if (target._children[i][\"data-table-index\"] != null) data_table_indexes.push(target._children[i][\"data-table-index\"]);else data_table_indexes = data_table_indexes.concat(getDataTableIndexesFromChildren(target._children[i]));\n        }\n      } else if (target[\"data-table-index\"] != null) data_table_indexes.push(target[\"data-table-index\"]);\n\n      return data_table_indexes;\n    }\n  },\n\n  _set_dendrogram_sort_order_state: function _set_dendrogram_sort_order_state() {\n    var self = this;\n    self.sortControl.attr(\"title\", function (index, attr) {\n      return self.options.dendrogram_sort_order ? \"Inputs are sorted in dendrogram order\" : \"Sort inputs in dendrogram order\";\n    }).toggleClass(\"selected\", self.options.dendrogram_sort_order);\n  },\n\n  _set_outputs: function _set_outputs() {\n    var self = this;\n    self.outputs_items.empty();\n    for (var i = 0; i < self.options.clusters.length; i++) {\n      $(\"<li role='presentation'>\").toggleClass(\"active\", self.options[\"cluster\"] == i).attr(\"data-cluster\", i).appendTo(self.outputs_items).append($('<a role=\"menuitem\" tabindex=\"-1\">').html(self.options.clusters[i]).click(function () {\n        var menu_item = $(this).parent();\n        if (menu_item.hasClass(\"active\")) return false;\n\n        self.outputs_items.find(\"li\").removeClass(\"active\");\n        menu_item.addClass(\"active\");\n\n        self.options.cluster = menu_item.attr(\"data-cluster\");\n        self.element.trigger(\"cluster-changed\", menu_item.attr(\"data-cluster\"));\n      }));\n    }\n    self.outputsButtonLabel.text(self.options.clusters[self.options[\"cluster\"]]);\n  },\n\n  resize_canvas: function resize_canvas() {\n    this._set_cluster();\n  },\n\n  _setOption: function _setOption(key, value) {\n    //console.log(\"timeseries.dendrogram._setOption()\", key, value);\n    this.options[key] = value;\n\n    if (key == \"cluster_data\") {\n      this._set_cluster();\n    } else if (key == \"color-options\") {\n      this.options.color_array = value.color_array;\n      this.options.color_scale = value.color_scale;\n      this._set_color();\n    } else if (key == \"color_scale\") {\n      this._set_color();\n    } else if (key == \"dendrogram_sort_order\") {\n      this._set_dendrogram_sort_order_state();\n    } else if (key == \"highlight\") {\n      if (value == undefined) this.options.highlight = [];\n      this._set_highlight();\n    }\n  }\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\")))\n\n//# sourceURL=webpack:///./web-server/plugins/slycat-timeseries-model/js/timeseries-dendrogram.js?");

/***/ }),

/***/ "./web-server/plugins/slycat-timeseries-model/js/timeseries-legend.js":
/*!****************************************************************************!*\
  !*** ./web-server/plugins/slycat-timeseries-model/js/timeseries-legend.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function($) {\n\nvar _d = __webpack_require__(/*! js/d3.min */ \"./web-server/js/d3.min.js\");\n\nvar _d2 = _interopRequireDefault(_d);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n$.widget(\"timeseries.legend\", {\n  options: {\n    width: 300,\n    height: 300,\n    metadata: null,\n    label: \"Label\",\n    min: null,\n    max: null,\n    border: 25,\n    v_type: null,\n    uniqueValues: null\n  },\n\n  _create: function _create() {\n    var self = this;\n\n    // Setup the legend ...\n    self.svg = _d2.default.select(self.element.get(0)).append(\"svg\");\n    self.legend_layer = self.svg.append(\"g\").attr(\"class\", \"legend\");\n    self.legend_axis_layer = self.legend_layer.append(\"g\").attr(\"class\", \"legend-axis\");\n\n    self.updates = {};\n    self.update_timer = null;\n\n    self._schedule_update({\n      update_width: true,\n      update_height: true,\n      render_legend: true,\n      update_legend_colors: true,\n      update_legend_position: true,\n      update_legend_axis: true,\n      update_label: true\n    });\n  },\n\n  _setOption: function _setOption(key, value) {\n    var self = this;\n\n    //console.log(\"timeseries.legend._setOption()\", key, value);\n    this.options[key] = value;\n\n    if (key == \"v\") {\n      self._schedule_update({ update_color_domain: true, render_data: true, render_selection: true, update_legend_axis: true });\n    } else if (key == \"width\") {\n      self._schedule_update({ update_width: true });\n    } else if (key == \"height\") {\n      self._schedule_update({ update_height: true, update_legend_position: true, update_legend_axis: true, update_label: true });\n    } else if (key == \"gradient\") {\n      self._schedule_update({ update_legend_colors: true });\n    } else if (key == \"min\" || key == \"max\") {\n      self._schedule_update({ update_legend_axis: true });\n    } else if (key == \"label\") {\n      self._schedule_update({ update_label: true });\n    }\n  },\n\n  _schedule_update: function _schedule_update(updates) {\n    var self = this;\n\n    for (var key in updates) {\n      self.updates[key] = updates[key];\n    }if (self.update_timer) return;\n\n    self.update_timer = window.setTimeout(function () {\n      self._update();\n    }, 0);\n  },\n\n  _update: function _update() {\n    var self = this;\n\n    //console.log(\"timeseries.legend._update()\", self.updates);\n    self.update_timer = null;\n\n    if (self.updates[\"update_width\"]) {\n      self.element.attr(\"width\", self.options.width);\n      self.svg.attr(\"width\", self.options.width);\n    }\n\n    if (self.updates[\"update_height\"]) {\n      self.element.attr(\"height\", self.options.height);\n      self.svg.attr(\"height\", self.options.height);\n    }\n\n    if (self.updates[\"render_legend\"]) {\n      var gradient = self.legend_layer.append(\"defs\").append(\"linearGradient\");\n      gradient.attr(\"id\", \"color-gradient\").attr(\"x1\", \"0%\").attr(\"y1\", \"0%\").attr(\"x2\", \"0%\").attr(\"y2\", \"100%\");\n\n      var colorbar = self.legend_layer.append(\"rect\").classed(\"color\", true).attr(\"width\", 10).attr(\"height\", 200).attr(\"x\", 0).attr(\"y\", 0).style(\"fill\", \"url(#color-gradient)\");\n    }\n\n    if (self.updates[\"update_legend_colors\"]) {\n      var gradient = self.legend_layer.select(\"#color-gradient\");\n      var stop = gradient.selectAll(\"stop\").data(self.options.gradient);\n      stop.exit().remove();\n      stop.enter().append(\"stop\");\n      stop.attr(\"offset\", function (d) {\n        return d.offset + \"%\";\n      }).attr(\"stop-color\", function (d) {\n        return d.color;\n      });\n    }\n\n    if (self.updates[\"update_legend_position\"]) {\n      var total_width = self.element.width();\n      var total_height = self.element.height();\n      var rectHeight = parseInt(total_height - self.options.border * 2);\n\n      var transx = self.options.border + 28; // 28 is height of label\n      var transy = self.options.border;\n      self.legend_layer.attr(\"transform\", \"translate(\" + transx + \",\" + transy + \")\").attr(\"data-transx\", transx).attr(\"data-transy\", transy);\n\n      self.legend_layer.select(\"rect.color\").attr(\"height\", rectHeight);\n    }\n\n    if (self.updates[\"update_legend_axis\"]) {\n      if (self.options.v_type != 'string') {\n        self.legend_scale = _d2.default.scale.linear().domain([self.options.max, self.options.min]).range([0, parseInt(self.legend_layer.select(\"rect.color\").attr(\"height\"))]);\n      } else {\n        self.legend_scale = _d2.default.scale.ordinal().domain(self.options.uniqueValues.reverse()).rangePoints([0, parseInt(self.legend_layer.select(\"rect.color\").attr(\"height\"))]);\n      }\n      self.legend_axis = _d2.default.svg.axis().scale(self.legend_scale).orient(\"right\");\n      self.legend_axis_layer.attr(\"transform\", \"translate(\" + parseInt(self.legend_layer.select(\"rect.color\").attr(\"width\")) + \",0)\").call(self.legend_axis);\n\n      // Need to re-assign fill style to get around this firefox bug: https://bugzilla.mozilla.org/show_bug.cgi?id=652991\n      // It only seems to affect fill gradients and only when the URI changes, like it does for us with bookmarking.\n      var colorbar = self.legend_layer.select(\"rect.color\").style(\"fill\", \"url(#color-gradient)\");\n    }\n\n    if (self.updates[\"update_label\"]) {\n      self.legend_layer.selectAll(\".label\").remove();\n\n      var rectHeight = parseInt(self.legend_layer.select(\"rect.color\").attr(\"height\"));\n      var x = -15;\n      var y = rectHeight / 2;\n\n      self.legend_layer.append(\"text\").attr(\"class\", \"label\").attr(\"x\", x).attr(\"y\", y).attr(\"transform\", \"rotate(-90,\" + x + \",\" + y + \")\").style(\"text-anchor\", \"middle\").style(\"font-weight\", \"bold\").text(self.options.label);\n    }\n\n    self.updates = {};\n  }\n}); /* Copyright (c) 2013, 2018 National Technology and Engineering Solutions of Sandia, LLC . Under the terms of Contract  DE-NA0003525 with National Technology and Engineering Solutions of Sandia, LLC, the U.S. Government  retains certain rights in this software. */\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\")))\n\n//# sourceURL=webpack:///./web-server/plugins/slycat-timeseries-model/js/timeseries-legend.js?");

/***/ }),

/***/ "./web-server/plugins/slycat-timeseries-model/js/timeseries-table.js":
/*!***************************************************************************!*\
  !*** ./web-server/plugins/slycat-timeseries-model/js/timeseries-table.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function($) {\n\nvar _d = __webpack_require__(/*! js/d3.min */ \"./web-server/js/d3.min.js\");\n\nvar _d2 = _interopRequireDefault(_d);\n\n__webpack_require__(/*! js/jquery.event.drag-2.2 */ \"./web-server/js/jquery.event.drag-2.2.js\");\n\n__webpack_require__(/*! js/slick.core */ \"./web-server/js/slick.core.js\");\n\n__webpack_require__(/*! js/slick.grid */ \"./web-server/js/slick.grid.js\");\n\n__webpack_require__(/*! js/slick.rowselectionmodel */ \"./web-server/js/slick.rowselectionmodel.js\");\n\n__webpack_require__(/*! js/slick.headerbuttons */ \"./web-server/js/slick.headerbuttons.js\");\n\n__webpack_require__(/*! js/slick.autotooltips */ \"./web-server/js/slick.autotooltips.js\");\n\nvar _chunker = __webpack_require__(/*! ./chunker */ \"./web-server/plugins/slycat-timeseries-model/js/chunker.js\");\n\nvar chunker = _interopRequireWildcard(_chunker);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/* Copyright (c) 2013, 2018 National Technology and Engineering Solutions of Sandia, LLC . Under the terms of Contract  DE-NA0003525 with National Technology and Engineering Solutions of Sandia, LLC, the U.S. Government  retains certain rights in this software. */\n\n////////////////////////////////////////////////////////////////////////////////////////\n// Slickgrid-based data table widget, for use with the timeseries model.\n\n$.widget(\"timeseries.table\", {\n  options: {\n    \"server-root\": \"\",\n    mid: null,\n    aid: null,\n    metadata: null,\n    \"row-selection\": [],\n    \"variable-selection\": [],\n    \"sort-variable\": null,\n    \"sort-order\": null,\n    colormap: null,\n    colorscale: null,\n    table_filter: [],\n    waveform_indexes: [],\n    selection: null,\n    row_count: null,\n    image_columns: []\n  },\n\n  _create: function _create() {\n    var self = this;\n\n    function value_formatter(value) {\n      return value == null ? \"&nbsp;\" : (value + \"\").replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n    }\n\n    function cell_formatter(row, cell, value, columnDef, dataContext) {\n      if (columnDef.colorscale) {\n        return \"<div class='highlightWrapper\" + (value == null ? \" null\" : \"\") + (_d2.default.hcl(columnDef.colorscale(value)).l > 50 ? \" light\" : \" dark\") + \"' style='background:\" + columnDef.colorscale(value) + \"'>\" + value_formatter(value) + \"</div>\";\n      } else if (value == null) return \"<div class='highlightWrapper\" + (value == null ? \" null\" : \"\") + \"'>\" + value_formatter(value) + \"</div>\";\n      return value_formatter(value);\n    }\n\n    function make_column(column_index, header_class, cell_class) {\n      var column = {\n        id: column_index,\n        field: column_index,\n        name: self.options.metadata[\"column-names\"][column_index],\n        sortable: false,\n        headerCssClass: header_class,\n        cssClass: cell_class,\n        formatter: cell_formatter,\n        header: {\n          buttons: [{\n            cssClass: self.options[\"sort-variable\"] == column_index ? self.options[\"sort-order\"] == \"ascending\" ? \"icon-sort-ascending\" : \"icon-sort-descending\" : \"icon-sort-off\",\n            tooltip: self.options[\"sort-variable\"] == column_index ? self.options[\"sort-order\"] == \"ascending\" ? \"Sort descending\" : \"Sort ascending\" : \"Sort ascending\",\n            command: self.options[\"sort-variable\"] == column_index ? self.options[\"sort-order\"] == \"ascending\" ? \"sort-descending\" : \"sort-ascending\" : \"sort-ascending\"\n          }]\n        }\n      };\n\n      // Special options for image columns\n      if (self.options.image_columns.indexOf(column_index) > -1) {\n        column.headerCssClass += \" headerImage\";\n      }\n\n      return column;\n    }\n\n    self.columns = [];\n    var header_class, cell_class;\n    // Last column is added as simid\n    self.columns.push(make_column(self.options.metadata[\"column-count\"] - 1, \"headerSimId\", \"rowSimId\"));\n    // rest of columns are added as inputs, except for media columns which are added as other\n    for (var i = 0; i < self.options.metadata[\"column-count\"] - 1; i++) {\n      header_class = \"headerInput\";\n      cell_class = \"rowInput\";\n      if (self.options.image_columns.indexOf(i) > -1) {\n        header_class = \"headerOther\";\n        cell_class = \"rowOther\";\n      }\n      self.columns.push(make_column(i, header_class, cell_class));\n    }\n  },\n\n  resize_canvas: function resize_canvas() {\n    var self = this;\n    self.grid.resizeCanvas();\n  },\n\n  _setOption: function _setOption(key, value) {\n    function set_sort(column, order) {\n      self.options[\"sort-variable\"] = column;\n      self.options[\"sort-order\"] = order;\n      self.data.set_sort(column, order, function () {\n        if (self.options[\"row-selection\"].length > 0) {\n          var selectedRows = self.data.getSimulationRowIndexes(self.options[\"row-selection\"]);\n          self.trigger_row_selection = false;\n          self.grid.setSelectedRows(selectedRows);\n          self.grid.resetActiveCell();\n          if (selectedRows.length) self.grid.scrollRowToTop(Math.min.apply(Math, selectedRows));\n        }\n      });\n      self.element.trigger(\"variable-sort-changed\", [column, order]);\n    }\n\n    var self = this;\n\n    if (key == \"row-selection\") {\n      // Unexpectedly at this point self.options[key] has already been set to value, so this always returns even when the row-selection is unique\n      //if(self._array_equal(self.options[key], value))\n      //  return;\n\n      self.options[key] = value;\n\n      var selectedRows = self.data.getSimulationRowIndexes(self.options[\"row-selection\"]);\n      self.trigger_row_selection = false;\n      self.grid.setSelectedRows(selectedRows);\n      self.grid.resetActiveCell();\n      if (selectedRows.length) self.grid.scrollRowToTop(Math.min.apply(Math, selectedRows));\n    } else if (key == \"row-selection-silent\") {\n      self.options[\"row-selection\"] = value;\n    } else if (key == \"variable-selection\") {\n      if (self._array_equal(self.options[key], value)) return;\n\n      self.options[key] = value;\n      self._color_variables(value);\n    } else if (key == \"colorscale\") {\n      self.options[key] = value;\n      self._color_variables(self.options[\"variable-selection\"]);\n    } else if (key == \"selection\") {\n      var initialize_grid = function initialize_grid(indices) {\n\n        var sorted_table_filter = undefined;\n        var retrieve_table_filter = undefined;\n\n        if (indices !== undefined) {\n          var sorted_rows = [];\n          // Reverse response indexes for descending sort order\n          if (self.options[\"sort-order\"] == 'descending') {\n            var plain_array = [];\n            for (var i = 0; i < indices.length; i++) {\n              plain_array.push(indices[i]);\n            }\n            indices = plain_array.reverse();\n          }\n          var response = [];\n          for (var i = 0; i < self.options.table_filter.length; i++) {\n            response.push(indices.indexOf(self.options.table_filter[i]));\n          }\n          sorted_rows = new Int32Array(response);\n\n          if (sorted_rows.length > 1) sorted_table_filter = Array.apply([], sorted_rows);else sorted_table_filter = [sorted_rows[0]];\n          retrieve_table_filter = sorted_table_filter.slice(0).sort(function (a, b) {\n            return a - b;\n          });\n        }\n\n        self.data = new self._data_provider({\n          server_root: self.options[\"server-root\"],\n          mid: self.options.mid,\n          aid: self.options.aid,\n          metadata: self.options.metadata,\n          sort_column: self.options[\"sort-variable\"],\n          sort_order: self.options[\"sort-order\"],\n          table_filter: self.options.table_filter,\n          row_count: self.options.row_count,\n          sorted_table_filter: sorted_table_filter,\n          retrieve_table_filter: retrieve_table_filter\n        });\n\n        if (self.grid) {\n          self.grid.setData(self.data);\n          self.data.setGrid(self.grid);\n          self.grid.invalidate();\n          if (self.options[\"row-selection\"].length > 0) {\n            var selectedRows = self.data.getSimulationRowIndexes(self.options[\"row-selection\"]);\n            self.trigger_row_selection = false;\n            self.grid.setSelectedRows(selectedRows);\n            self.grid.resetActiveCell();\n            if (selectedRows.length) self.grid.scrollRowToTop(Math.min.apply(Math, selectedRows));\n          }\n        } else {\n          self.trigger_row_selection = true;\n          self.grid = new Slick.Grid(self.element, self.data, self.columns, { explicitInitialization: true, enableColumnReorder: false });\n          self.data.setGrid(self.grid);\n\n          var header_buttons = new Slick.Plugins.HeaderButtons();\n          header_buttons.onCommand.subscribe(function (e, args) {\n            var column = args.column;\n            var button = args.button;\n            var command = args.command;\n            var grid = args.grid;\n\n            for (var i in self.columns) {\n              self.columns[i].header.buttons[0].cssClass = \"icon-sort-off\";\n              self.columns[i].header.buttons[0].tooltip = \"Sort ascending\";\n              self.columns[i].header.buttons[0].command = \"sort-ascending\";\n              grid.updateColumnHeader(self.columns[i].id);\n            }\n\n            if (command == \"sort-ascending\") {\n              button.cssClass = 'icon-sort-ascending';\n              button.command = 'sort-descending';\n              button.tooltip = 'Sort descending';\n              set_sort(column.id, \"ascending\");\n            } else if (command == \"sort-descending\") {\n              button.cssClass = 'icon-sort-descending';\n              button.command = 'sort-ascending';\n              button.tooltip = 'Sort ascending';\n              set_sort(column.id, \"descending\");\n            }\n          });\n\n          self.grid.registerPlugin(header_buttons);\n          self.grid.registerPlugin(new Slick.AutoTooltips({ enableForHeaderCells: true }));\n\n          self.grid.setSelectionModel(new Slick.RowSelectionModel());\n\n          self.grid.onSelectedRowsChanged.subscribe(function (e, selection) {\n            // Don't trigger a selection event unless the selection was changed by user interaction (i.e. not outside callers or changing the sort order).\n            if (self.trigger_row_selection) {\n              var waveform_indexes = [];\n              for (var i = 0; i < selection.rows.length; i++) {\n                waveform_indexes.push(self.grid.getDataItem(selection.rows[i])[self.options.metadata[\"column-count\"] - 1]);\n              }\n              self.options[\"row-selection\"] = waveform_indexes;\n              self.element.trigger(\"row-selection-changed\", [waveform_indexes]);\n            }\n            self.trigger_row_selection = true;\n          });\n\n          self.grid.onHeaderClick.subscribe(function (e, args) {\n            if (!self._array_equal([args.column.field], self.options[\"variable-selection\"]) && self.options.image_columns.indexOf(args.column.field) == -1) {\n              self.options[\"variable-selection\"] = [args.column.field];\n              // self._color_variables(self.options[\"variable-selection\"]);\n              self.element.trigger(\"variable-selection-changed\", { variable: self.options[\"variable-selection\"], colorscale: args.column.colorscale });\n            }\n          });\n\n          self._color_variables(self.options[\"variable-selection\"]);\n\n          self.grid.init();\n\n          if (self.options[\"row-selection\"].length > 0) {\n            var selectedRows = self.data.getSimulationRowIndexes(self.options[\"row-selection\"]);\n            self.trigger_row_selection = false;\n            self.grid.setSelectedRows(selectedRows);\n            self.grid.resetActiveCell();\n            if (selectedRows.length) self.grid.scrollRowToTop(Math.min.apply(Math, selectedRows));\n          }\n        }\n\n        self.data.onDataLoaded.subscribe(function (e, args) {\n          for (var i = args.from; i <= args.to; i++) {\n            self.grid.invalidateRow(i);\n          }\n          self.grid.render();\n        });\n      };\n\n      self.options[key] = value;\n\n      var data_table_index, waveform_index;\n      var table_filter = [];\n      var waveform_indexes = [];\n      $.each(value, function (index, node) {\n        data_table_index = node[\"data-table-index\"];\n        waveform_index = node[\"waveform-index\"];\n\n        if (data_table_index == null) return;\n\n        table_filter.push(data_table_index);\n        waveform_indexes.push(waveform_index);\n      });\n      self.options.table_filter = table_filter;\n      self.options.waveform_indexes = waveform_indexes;\n      self.options.row_count = table_filter.length;\n\n      if (self.options[\"sort-variable\"] !== null && self.options[\"sort-order\"] !== null && self.options.table_filter.length > 0) {\n        // Need to retrieve the sorted_table_filter first because everything else relies on it.\n\n        if (self.options[\"sort-variable\"] == self.options.metadata[\"column-count\"] - 1) {\n          // we are sorting by the index column, so we can just make the data we need.\n          initialize_grid(new Int32Array(_d2.default.range(self.options.metadata[\"row-count\"])));\n        } else {\n          var request = new XMLHttpRequest();\n          request.open(\"GET\", self.options[\"server-root\"] + \"models/\" + self.options.mid + \"/arraysets/\" + self.options.aid + \"/data?hyperchunks=0/rank(a\" + self.options[\"sort-variable\"] + ',\"asc\")/...&byteorder=' + (chunker.is_little_endian() ? \"little\" : \"big\"));\n          request.responseType = \"arraybuffer\";\n          request.onload = function (e) {\n            var indices = [];\n            var data = new Int32Array(this.response);\n            // Filtering out every other element in the reponse array, because it's full of extraneous 0 (zeros) for some reason.\n            // Need to figure out why, but this is a fix for now.\n            for (var i = 0; i < data.length; i = i + 2) {\n              indices.push(data[i]);\n            }\n            indices = new Int32Array(indices);\n\n            initialize_grid(indices);\n          };\n          request.send();\n        }\n      } else {\n        initialize_grid();\n      }\n    } else if (key == \"sort-variable\") {\n      self.options[key] = value;\n      if (value === null) {\n        self.options[\"sort-order\"] = null;\n      }\n      set_sort(self.options[\"sort-variable\"], self.options[\"sort-order\"]);\n      // Set all column header buttons to \"sort-off\" state\n      for (var i in self.columns) {\n        self.columns[i].header.buttons[0].cssClass = \"icon-sort-off\";\n        self.columns[i].header.buttons[0].tooltip = \"Sort ascending\";\n        self.columns[i].header.buttons[0].command = \"sort-ascending\";\n        self.grid.updateColumnHeader(self.columns[i].id);\n      }\n    }\n  },\n\n  _color_variables: function _color_variables(variables) {\n    var self = this;\n\n    var columns = self.grid.getColumns();\n    for (var i in columns) {\n      var column = columns[i];\n      if (self.options.colorscale !== null && $.inArray(column.id, variables) != -1) {\n        column.colorscale = self.options.colorscale;\n        column.cssClass = column.cssClass.split(\" \")[0] + \" highlight\";\n      } else {\n        column.colorscale = null;\n        column.cssClass = column.cssClass.split(\" \")[0];\n      }\n      // if(self.options.colormap !== null && $.inArray(column.id, variables) != -1)\n      // {\n      //   // Make a copy of our global colormap, then adjust its domain to match our column-specific data.\n      //   column.colormap = self.options.colormap.copy();\n\n      //   var new_domain = []\n      //   var domain_scale = d3.scale.linear()\n      //     .domain([0, column.colormap.range().length - 1])\n      //     .range([self.options.metadata[\"column-min\"][column.id], self.options.metadata[\"column-max\"][column.id]]);\n      //   for(var i in column.colormap.range())\n      //     new_domain.push(domain_scale(i));\n      //   column.colormap.domain(new_domain);\n\n      //   column.cssClass = column.cssClass.split(\" \")[0] + \" highlight\";\n      //   column.highlighted = true;\n      // }\n      // else\n      // {\n      //   column.colormap = null;\n      //   column.cssClass = column.cssClass.split(\" \")[0];\n      //   column.highlighted = false;\n      // }\n    }\n\n    self.grid.invalidate();\n  },\n\n  _data_provider: function _data_provider(parameters) {\n    var self = this;\n\n    self.server_root = parameters.server_root;\n    self.mid = parameters.mid;\n    self.aid = parameters.aid;\n    self.metadata = parameters.metadata;\n    self.sort_column = parameters.sort_column;\n    self.sort_order = parameters.sort_order;\n    self.table_filter = parameters.table_filter;\n    if (parameters.sorted_table_filter == undefined) self.sorted_table_filter = parameters.table_filter;else self.sorted_table_filter = parameters.sorted_table_filter;\n    if (parameters.retrieve_table_filter == undefined) self.retrieve_table_filter = parameters.table_filter;else self.retrieve_table_filter = parameters.retrieve_table_filter;\n    self.row_count = parameters.row_count;\n    self.ranked_indices = {};\n\n    self.pages = {};\n    self.pages_in_progress = {};\n    self.page_size = 50;\n\n    self.onDataLoaded = new Slick.Event();\n\n    self.get_indices_old = function (sortedUnsorted, rows, callback, asynchronous) {\n      if (asynchronous != false) asynchronous = true;\n\n      if (rows.length == 0) {\n        callback([]);\n        return;\n      }\n\n      var sort = \"\";\n      if (self.sort_column !== null && self.sort_order !== null) sort = \"&sort=\" + self.sort_column + \":\" + self.sort_order;\n\n      var row_string = \"\";\n      for (var i = 0; i < rows.length; ++i) {\n        row_string += rows[i];\n        break;\n      }\n      for (var i = 1; i < rows.length; ++i) {\n        row_string += \",\";\n        row_string += rows[i];\n      }\n\n      // XMLHttpRequest does not support synchronous retrieval with arraybuffer, so falling back to ajax with no arraybuffer for initial synchronous sorted table filter retrieval.\n      if (asynchronous) {\n        var request = new XMLHttpRequest();\n        request.open(\"GET\", self.server_root + \"models/\" + self.mid + \"/tables/\" + self.aid + \"/arrays/0/\" + sortedUnsorted + \"-indices?rows=\" + row_string + \"&index=Index&byteorder=\" + (chunker.is_little_endian() ? \"little\" : \"big\") + sort);\n        request.responseType = \"arraybuffer\";\n        request.callback = callback;\n        request.onload = function (e) {\n          this.callback(new Int32Array(this.response));\n        };\n        request.send();\n      } else {\n        $.ajax({\n          type: \"GET\",\n          url: self.server_root + \"models/\" + self.mid + \"/tables/\" + self.aid + \"/arrays/0/\" + sortedUnsorted + \"-indices?rows=\" + row_string + \"&index=Index\" + sort,\n          async: false,\n          callback: callback,\n          success: function success(data) {\n            this.callback(new Int32Array(data));\n          }\n        });\n      }\n    };\n\n    self.get_indices = function (direction, rows, callback) {\n      if (rows.length == 0) {\n        callback([]);\n        return;\n      }\n      // We have no sort column or order, so just returning the same rows as were asked for since they're in the same order\n      if (self.sort_column == null || self.sort_order == null) {\n        callback(rows);\n      } else {\n        if (self.ranked_indices[self.sort_column]) {\n          // we have data for this column, so figure out what to return\n          var indices = self.ranked_indices[self.sort_column];\n          // Reverse response indexes for descending sort order\n          if (self.sort_order == 'descending') {\n            var plain_array = [];\n            for (var i = 0; i < indices.length; i++) {\n              plain_array.push(indices[i]);\n            }\n            indices = plain_array.reverse();\n          }\n          var response = [];\n          for (var i = 0; i < rows.length; i++) {\n            if (direction == \"unsorted\") {\n              response.push(indices[rows[i]]);\n            } else if (direction == \"sorted\") {\n              response.push(indices.indexOf(rows[i]));\n            }\n          }\n          callback(new Int32Array(response));\n        } else {\n          if (self.sort_column == self.metadata[\"column-count\"] - 1) {\n            // we are sorting by the index column, so we can just make the data we need.\n            self.ranked_indices[self.sort_column] = new Int32Array(_d2.default.range(self.metadata[\"row-count\"]));\n            self.get_indices(direction, rows, callback);\n          } else {\n            // we have no data for this column, so go retrieve it and call this function again.\n            var request = new XMLHttpRequest();\n            request.open(\"GET\", self.server_root + \"models/\" + self.mid + \"/arraysets/\" + self.aid + \"/data?hyperchunks=0/rank(a\" + self.sort_column + ',\"asc\")/...&byteorder=' + (chunker.is_little_endian() ? \"little\" : \"big\"));\n            request.responseType = \"arraybuffer\";\n            request.direction = direction;\n            request.rows = rows;\n            request.callback = callback;\n            request.onload = function (e) {\n              var indices = [];\n              var data = new Int32Array(this.response);\n              // Filtering out every other element in the reponse array, because it's full of extraneous 0 (zeros) for some reason.\n              // Need to figure out why, but this is a fix for now.\n              for (var i = 0; i < data.length; i = i + 2) {\n                indices.push(data[i]);\n              }\n              self.ranked_indices[self.sort_column] = new Int32Array(indices);\n              self.get_indices(this.direction, this.rows, this.callback);\n            };\n            request.send();\n          }\n        }\n      }\n    };\n\n    self.setGrid = function (grid) {\n      self.grid = grid;\n    };\n\n    self.getLength = function () {\n      return self.row_count;\n    };\n\n    self.getItem_old = function (index) {\n      var column_begin = 0;\n      var column_end = self.metadata[\"column-count\"];\n      var page = Math.floor(index / self.page_size);\n      var page_begin = page * self.page_size;\n\n      if (!(page in self.pages)) {\n        var row_begin = page_begin;\n        var row_end = (page + 1) * self.page_size;\n\n        var sort = \"\";\n        if (self.sort_column !== null && self.sort_order !== null) {\n          sort = \"&sort=\" + self.sort_column + \":\" + self.sort_order;\n        }\n\n        var rowsToRetrieve = self.retrieve_table_filter.slice(row_begin, row_end).join(',');\n\n        $.ajax({\n          type: \"GET\",\n          url: self.server_root + \"models/\" + self.mid + \"/tables/\" + self.aid + \"/arrays/0/chunk?rows=\" + rowsToRetrieve + \"&columns=\" + column_begin + \"-\" + column_end + \"&index=Index\" + sort,\n          async: false,\n          success: function success(data) {\n            self.pages[page] = data;\n          },\n          error: function error(request, status, reason_phrase) {\n            console.log(\"error\", request, status, reason_phrase);\n          }\n        });\n      }\n\n      var result = {};\n      for (var i = column_begin; i != column_end; ++i) {\n        result[i] = self.pages[page].data[i][index - page_begin];\n      }return result;\n    };\n\n    self.getItem = function (index) {\n      var column_begin = 0;\n      var column_end = self.metadata[\"column-count\"];\n      var page = Math.floor(index / self.page_size);\n      var page_begin = page * self.page_size;\n\n      if (self.pages_in_progress[page]) {\n        return null;\n      }\n\n      if (!(page in self.pages)) {\n        self.pages_in_progress[page] = true;\n        var row_begin = page_begin;\n        var row_end = (page + 1) * self.page_size;\n\n        var rowsToRetrieve = self.retrieve_table_filter.slice(row_begin, row_end).join('|');\n\n        var sort = \"\";\n        if (self.sort_column !== null && self.sort_order !== null) {\n          var sort_column = \"a\" + self.sort_column;\n          var sort_order = self.sort_order;\n          if (sort_order == 'ascending') {\n            sort_order = 'asc';\n          } else if (sort_order == 'descending') {\n            sort_order = 'desc';\n          }\n          if (self.sort_column == self.metadata[\"column-count\"] - 1) sort_column = \"index(0)\";\n          sort = \"/order: rank(\" + sort_column + ', \"' + sort_order + '\")';\n        }\n\n        $.ajax({\n          type: \"GET\",\n          url: self.server_root + \"models/\" + self.mid + \"/arraysets/\" + self.aid + \"/data?hyperchunks=0/\" + column_begin + \":\" + (column_end - 1) + \"|index(0)\" + sort + \"/\" + rowsToRetrieve,\n          success: function success(data) {\n            self.pages[page] = [];\n            var columns = column_end - column_begin;\n            var rows = data.length / columns;\n            for (var row = 0; row < rows; row++) {\n              var result = {};\n              for (var column = column_begin; column != column_end; ++column) {\n                result[column] = data[(column - column_begin) * rows + row];\n              }\n              self.pages[page].push(result);\n            }\n            self.pages_in_progress[page] = false;\n            self.onDataLoaded.notify({ from: row_begin, to: row_end });\n          },\n          error: function error(request, status, reason_phrase) {\n            console.log(\"error\", request, status, reason_phrase);\n          }\n        });\n        return null;\n      }\n\n      return self.pages[page][index - page_begin];\n    };\n\n    self.getItemMetadata = function (index) {\n      return null;\n    };\n\n    self.set_sort = function (column, order, callback) {\n      if (column == self.sort_column && order == self.sort_order) {\n        return;\n      } else if (column == null || order == null) {\n        self.sort_column = column;\n        self.sort_order = order;\n        self.sorted_table_filter = self.table_filter;\n        self.retrieve_table_filter = self.table_filter;\n        self.pages = {};\n        self.grid.invalidate();\n        callback();\n      } else {\n        self.sort_column = column;\n        self.sort_order = order;\n        self.get_indices(\"sorted\", self.table_filter, function (sorted_rows) {\n          if (sorted_rows.length > 1) self.sorted_table_filter = Array.apply([], sorted_rows);else self.sorted_table_filter = [sorted_rows[0]];\n          self.retrieve_table_filter = self.sorted_table_filter.slice(0).sort(function (a, b) {\n            return a - b;\n          });\n          self.pages = {};\n          self.grid.invalidate();\n          callback();\n        });\n      }\n    };\n\n    self.getSimulationRowIndexes = function (simulation_indexes) {\n      var table_filter_index, sorted_table_filter_element, retrieve_table_filter_index;\n      var result = [];\n      for (var i = 0; i < simulation_indexes.length; i++) {\n        table_filter_index = self.table_filter.indexOf(simulation_indexes[i]);\n        if (table_filter_index > -1) {\n          sorted_table_filter_element = self.sorted_table_filter[table_filter_index];\n          retrieve_table_filter_index = self.retrieve_table_filter.indexOf(sorted_table_filter_element);\n          result.push(retrieve_table_filter_index);\n        }\n      }\n      return result;\n    };\n  },\n\n  _array_equal: function _array_equal(a, b) {\n    return $(a).not(b).length == 0 && $(b).not(a).length == 0;\n  }\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\")))\n\n//# sourceURL=webpack:///./web-server/plugins/slycat-timeseries-model/js/timeseries-table.js?");

/***/ }),

/***/ "./web-server/plugins/slycat-timeseries-model/js/timeseries-waveformplot.js":
/*!**********************************************************************************!*\
  !*** ./web-server/plugins/slycat-timeseries-model/js/timeseries-waveformplot.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function($) {\n\nvar _d = __webpack_require__(/*! js/d3.min */ \"./web-server/js/d3.min.js\");\n\nvar _d2 = _interopRequireDefault(_d);\n\nvar _jqueryKnob = __webpack_require__(/*! jquery-knob */ \"./node_modules/jquery-knob/dist/jquery.knob.min.js\");\n\nvar _jqueryKnob2 = _interopRequireDefault(_jqueryKnob);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/* Copyright (c) 2013, 2018 National Technology and Engineering Solutions of Sandia, LLC . Under the terms of Contract  DE-NA0003525 with National Technology and Engineering Solutions of Sandia, LLC, the U.S. Government  retains certain rights in this software. */\n\n///////////////////////////////////////////////////////////////////////////////////////////\n// HTML5 DOM waveform visualization, for use with the timeseries model.\n\n$.widget(\"timeseries.waveformplot\", {\n  options: {\n    \"server-root\": \"\",\n    mid: null,\n    waveforms: null, // Time & value data for all waveforms, not just the visible ones\n    selection: null, // Array of ids of waveforms that are visible\n    highlight: [],\n    color_array: null,\n    color_scale: null,\n    nullWaveformColor: \"gray\",\n    nullWaveformDasharray: \"5,5\",\n    hover: []\n  },\n\n  _create: function _create() {\n    var self = this;\n\n    this.waveforms = this.options.waveforms;\n    this.container = _d2.default.select(\"#waveform-viewer\");\n    this.width = $(\"#waveform-pane\").width();\n    this.height = $(\"#waveform-pane\").height();\n    this.padding_top = 20;\n    this.padding_right = 20;\n    this.padding_bottom = 40;\n    this.padding_left = 60;\n    this.diagram_width = this.width - this.padding_right - this.padding_left;\n    this.diagram_height = this.height - this.padding_top - this.padding_bottom;\n\n    this.waveformPieContainer = $(\"#waveform-progress\");\n    this.waveformPie = $(\"#waveform-progress .waveformPie\");\n    this.waveformPie.knob({\n      'min': 0,\n      'readOnly': true,\n      'displayInput': false,\n      'fgColor': '#7767B0',\n      'bgColor': '#DBD9EB',\n      'width': 200,\n      'height': 200,\n      'thickness': 0.35,\n      'step': 1\n    });\n\n    this.waveformSelectionPieContainer = $(\"#waveform-selection-progress\");\n    this.waveformSelectionPie = $(\"#waveform-selection-progress .waveformPie\");\n    this.waveformSelectionPie.knob({\n      'min': 0,\n      'readOnly': true,\n      'displayInput': false,\n      'fgColor': '#7767B0',\n      'bgColor': '#DBD9EB',\n      'width': 200,\n      'height': 200,\n      'thickness': 0.35,\n      'step': 1\n    });\n\n    this.waveformSelectorPieContainer = $(\"#waveform-selector-progress\");\n    this.waveformSelectorPie = $(\"#waveform-selector-progress .waveformPie\");\n    this.waveformSelectorPie.knob({\n      'min': 0,\n      'readOnly': true,\n      'displayInput': false,\n      'fgColor': '#7767B0',\n      'bgColor': '#DBD9EB',\n      'width': 15,\n      'height': 15,\n      'thickness': 0.50,\n      'step': 1\n    });\n\n    this.waveformProcessingTimeout = { timeoutID: null };\n    this.waveformSelectionProcessingTimeout = { timeoutID: null };\n    this.previewWaveformsTimeout = null;\n    this.showWaveformPieContainerTimeout = null;\n    this.showWaveformSelectionPieContainerTimeout = null;\n    this.showWaveformSelectorPieContainerTimeout = null;\n    this.color_array = this.options.color_array;\n    this.color_scale = this.options.color_scale;\n\n    this.container.selectAll(\"canvas\").remove();\n\n    this.x_axis_layer = this.container.append(\"g\").attr(\"class\", \"x-axis\");\n    this.y_axis_layer = this.container.append(\"g\").attr(\"class\", \"y-axis\");\n\n    // this.canvas_datum = d3.select(self.element.parent().get(0)).append(\"canvas\")\n    this.canvas_datum = _d2.default.select(self.element.parent().get(0)).insert(\"canvas\", \":first-child\").style({\n      'position': 'absolute',\n      'left': this.padding_left + 'px',\n      'top': this.padding_top + 'px'\n    }).node();\n\n    // alpha true or false doesn't seem to make any difference at 15k waveforms x 1000 samples\n    this.canvas_datum_ctx = this.canvas_datum.getContext(\"2d\", { alpha: true });\n\n    this.canvas_selection = _d2.default.select(self.element.parent().get(0)).append(\"canvas\").style({\n      'position': 'absolute',\n      'left': this.padding_left + 'px',\n      'top': this.padding_top + 'px'\n    }).node();\n    this.canvas_selection_ctx = this.canvas_selection.getContext(\"2d\", { alpha: true });\n\n    this.canvas_hover = _d2.default.select(self.element.parent().get(0)).append(\"canvas\").style({\n      'position': 'absolute',\n      'left': this.padding_left + 'px',\n      'top': this.padding_top + 'px'\n    }).node();\n    this.canvas_hover_ctx = this.canvas_hover.getContext(\"2d\", { alpha: true });\n\n    this.canvas_offscreen = document.createElement('canvas');\n    this.canvas_offscreen_ctx = this.canvas_offscreen.getContext('2d', { alpha: true });\n\n    this.canvas_picker = document.createElement('canvas');\n    this.canvas_picker_ctx = this.canvas_picker.getContext('2d', { alpha: true });\n\n    function RGBtoInt(r, g, b) {\n      return r << 16 | g << 8 | b;\n    }\n\n    function hover(event) {\n      var x = event.layerX;\n      var y = event.layerY;\n\n      var pixelPick = self.canvas_picker_ctx.getImageData(x, y, 1, 1);\n      var dataPick = pixelPick.data;\n      var rgbaPick = 'rgba(' + dataPick[0] + ',' + dataPick[1] + ',' + dataPick[2] + ',' + dataPick[3] + ')';\n\n      var id, isPointInStrokePick, path;\n      if (dataPick[3] == 255) {\n        id = RGBtoInt(dataPick[0], dataPick[1], dataPick[2]);\n        // console.log('you are hovering over waveform with id ' + id);\n\n        path = self.paths[id];\n\n        isPointInStrokePick = self.canvas_picker_ctx.isPointInStroke(path, x, y);\n\n        if (isPointInStrokePick) {\n          self.options.hover = [id];\n          self._hover();\n        }\n      } else {\n        // Only clear hover if there is something hovered\n        if (self.options.hover.length > 0) {\n          self.options.hover = [];\n          self._hover();\n        }\n      }\n    }\n    this.canvas_hover.addEventListener('mousemove', hover);\n\n    function click(event) {\n      // Add or remove waveform to highlights if ctrl clicked\n      if (event.ctrlKey || event.metaKey) {\n        var index = self.options.highlight.indexOf(self.options.hover[0]);\n        if (index < 0) {\n          self.options.highlight.push(self.options.hover[0]);\n        } else {\n          self.options.highlight.splice(index, 1);\n          // Clear hover effect to provide feedback that waveform was removed from highlight\n          self.options.hover = [];\n          self._hover();\n        }\n      }\n      // Select only clicked waveform\n      else {\n          self.options.highlight = self.options.hover.slice();\n        }\n      self._selection();\n      self.element.trigger(\"waveform-selection-changed\", [self.options.highlight]);\n      event.stopPropagation();\n    }\n    this.canvas_hover.addEventListener('click', click);\n\n    // Set all waveforms to visible if this options has not been set\n    var visible = this.options.selection;\n    if (visible === null) {\n      visible = [];\n      for (var i = 0; i < this.waveforms.length; i++) {\n        visible.push(this.waveforms[i][\"input-index\"]);\n      }\n      this.options.selection = visible;\n    }\n\n    this._set_visible();\n    this._selection();\n  },\n\n  // Calculate paths\n  _calculate_paths: function _calculate_paths() {\n    var self = this;\n    var x_min = _d2.default.min(this.waveforms, function (waveform) {\n      return _d2.default.min(waveform[\"time\"]);\n    });\n    var x_max = _d2.default.max(this.waveforms, function (waveform) {\n      return _d2.default.max(waveform[\"time\"]);\n    });\n    var y_min = _d2.default.min(this.waveforms, function (waveform) {\n      return _d2.default.min(waveform[\"value\"]);\n    });\n    var y_max = _d2.default.max(this.waveforms, function (waveform) {\n      return _d2.default.max(waveform[\"value\"]);\n    });\n\n    this.x = _d2.default.scale.linear().domain([x_min, x_max]).range([0, this.diagram_width]);\n\n    this.y = _d2.default.scale.linear().domain([y_max, y_min]).range([0, this.diagram_height]);\n\n    this.paths = [];\n    var waveform, current_waveform_length, p;\n    for (var j = 0; j < this.waveforms.length; j++) {\n      p = new Path2D();\n      waveform = this.waveforms[j];\n      current_waveform_length = waveform[\"time\"].length;\n\n      for (var i = 0; i != current_waveform_length; ++i) {\n        p.moveTo(self.x(waveform[\"time\"][i]), self.y(waveform[\"value\"][i]));\n        break;\n      }\n      for (var i = 1; i < current_waveform_length; ++i) {\n        p.lineTo(self.x(waveform[\"time\"][i]), self.y(waveform[\"value\"][i]));\n      }\n\n      this.paths[waveform[\"input-index\"]] = p;\n    }\n  },\n\n  // Renders waveforms\n  _set_visible: function _set_visible() {\n    var self = this;\n    var visible = this.options.selection;\n    this.waveforms = this.options.waveforms;\n\n    // Cancel any previously started work\n    self._stopProcessingWaveforms();\n\n    var x_min = _d2.default.min(this.waveforms, function (waveform) {\n      return _d2.default.min(waveform[\"time\"]);\n    });\n    var x_max = _d2.default.max(this.waveforms, function (waveform) {\n      return _d2.default.max(waveform[\"time\"]);\n    });\n    var y_min = _d2.default.min(this.waveforms, function (waveform) {\n      return _d2.default.min(waveform[\"value\"]);\n    });\n    var y_max = _d2.default.max(this.waveforms, function (waveform) {\n      return _d2.default.max(waveform[\"value\"]);\n    });\n\n    this.x = _d2.default.scale.linear().domain([x_min, x_max]).range([0, this.diagram_width]);\n\n    this.y = _d2.default.scale.linear().domain([y_max, y_min]).range([0, this.diagram_height]);\n\n    this.x_axis = _d2.default.svg.axis().scale(this.x).orient(\"bottom\");\n    this.x_axis_layer.attr(\"transform\", \"translate(\" + (this.padding_left - 1) + \",\" + (this.padding_top + this.diagram_height + 1) + \")\").call(this.x_axis);\n\n    this.y_axis = _d2.default.svg.axis().scale(this.y).orient(\"left\");\n    this.y_axis_layer.attr(\"transform\", \"translate(\" + (this.padding_left - 1) + \",\" + (this.padding_top + 1) + \")\").call(this.y_axis);\n\n    _d2.default.selectAll(\"canvas\").attr(\"width\", this.diagram_width).attr(\"height\", this.diagram_height);\n\n    this.canvas_offscreen.width = this.diagram_width;\n    this.canvas_offscreen.height = this.diagram_height;\n\n    this.canvas_picker.width = this.diagram_width;\n    this.canvas_picker.height = this.diagram_height;\n\n    var fillStyle = $(\"#color-switcher\").colorswitcher(\"get_background\");\n    var opacity = $(\"#color-switcher\").colorswitcher(\"get_opacity\");\n    this.canvas_hover_ctx.fillStyle = \"rgba(\" + fillStyle.r + \", \" + fillStyle.g + \", \" + fillStyle.b + \", \" + opacity + \")\";\n    this.canvas_selection_ctx.fillStyle = \"rgba(\" + fillStyle.r + \", \" + fillStyle.g + \", \" + fillStyle.b + \", \" + opacity + \")\";\n\n    var waveform_subset = [];\n    if (visible !== undefined) {\n      for (var i = 0; i < visible.length; i++) {\n        waveform_subset.push(self.waveforms[visible[i]]);\n      }\n    } else {\n      waveform_subset = self.waveforms;\n    }\n\n    function intToRGB(int) {\n      var r = int >> 16 & 0xff;\n      var g = int >> 8 & 0xff;\n      var b = int & 0xff;\n      return _d2.default.rgb(r, g, b);\n    }\n\n    this.canvas_offscreen_ctx.lineWidth = 1;\n    this.canvas_picker_ctx.lineWidth = 3;\n    this.canvas_hover_ctx.lineWidth = 3;\n    this.canvas_selection_ctx.lineWidth = 3;\n\n    var result, current_waveform, p, strokeStyle;\n    var color_scale_and_color_array = self.options.color_scale != null && self.options.color_array != null;\n\n    this.waveformsLength = waveform_subset.length;\n    if (this.waveformsLength > 0) {\n      self.waveformPie.trigger('configure', {\n        \"max\": this.waveformsLength\n      });\n      self.waveformSelectorPie.trigger('configure', {\n        \"max\": this.waveformsLength\n      });\n\n      // Don't want the progress indicator showing up every time. Only if the delay is longer than 1 second.\n      self.showWaveformPieContainerTimeout = setTimeout(function () {\n        self.waveformPieContainer.show(0);\n      }, 1000);\n\n      this._calculate_paths();\n\n      self._timedProcessArray(waveform_subset, processWaveform, finishedProcessingWaveforms, self.waveformPie, self.waveformProcessingTimeout);\n      previewWaveforms(self.canvas_offscreen, self.canvas_datum_ctx);\n    }\n\n    function processWaveform(waveform) {\n      var coloredLine = color_scale_and_color_array && self.options.color_array[waveform[\"input-index\"]] !== null;\n      if (coloredLine) {\n        var strokeStyle = self.options.color_scale(self.options.color_array[waveform[\"input-index\"]]);\n      } else {\n        var strokeStyle = $(\"#color-switcher\").colorswitcher(\"get_null_color\");\n        self.canvas_offscreen_ctx.setLineDash([8, 4]);\n      }\n      self.canvas_offscreen_ctx.strokeStyle = strokeStyle;\n      self.canvas_offscreen_ctx.stroke(self.paths[waveform[\"input-index\"]]);\n\n      if (!coloredLine) {\n        self.canvas_offscreen_ctx.setLineDash([]);\n      }\n    }\n\n    function processWaveformLookup(waveform) {\n      self.canvas_picker_ctx.strokeStyle = intToRGB(waveform[\"input-index\"]);\n      self.canvas_picker_ctx.stroke(self.paths[waveform[\"input-index\"]]);\n      // console.log('just stroked lookup: ' + waveform[\"input-index\"]);\n    }\n\n    function finishedProcessingWaveformsLookup() {\n      clearTimeout(self.showWaveformSelectorPieContainerTimeout);\n      self.waveformSelectorPieContainer.hide();\n    }\n\n    function finishedProcessingWaveforms() {\n      // Cancelling the timeout that was set to delay progress indicator display\n      clearTimeout(self.showWaveformPieContainerTimeout);\n      self.waveformPieContainer.hide();\n      clearTimeout(self.previewWaveformsTimeout);\n      self.previewWaveformsTimeout = undefined;\n      self.canvas_datum_ctx.drawImage(self.canvas_offscreen, 0, 0);\n\n      // Don't want the progress indicator showing up every time. Only if the delay is longer than 1 second.\n      self.showWaveformSelectorPieContainerTimeout = setTimeout(function () {\n        self.waveformSelectorPieContainer.show(0);\n      }, 1000);\n\n      self._timedProcessArray(waveform_subset, processWaveformLookup, finishedProcessingWaveformsLookup, self.waveformSelectorPie, self.waveformProcessingTimeout);\n    }\n\n    function previewWaveforms(sourceCanvas, destinationContext, timeout) {\n      if (timeout == null) timeout = 500;\n\n      self.previewWaveformsTimeout = setTimeout(function work() {\n        destinationContext.drawImage(sourceCanvas, 0, 0);\n        if (self.previewWaveformsTimeout) {\n          self.previewWaveformsTimeout = setTimeout(work, timeout);\n        }\n      }, timeout);\n    }\n  },\n\n  /* Hover effect for waveforms */\n  _hover: function _hover(waveforms) {\n    var self = this;\n    var fillStyle;\n\n    // Only hover a waveform if it's part of the current selection\n    var selection = self.options.selection;\n    var hover = self.options.hover;\n    var inCurrentSelection = [];\n    for (var i = 0; i < hover.length; i++) {\n      if (selection.indexOf(hover[i]) > -1) {\n        inCurrentSelection.push(hover[i]);\n      }\n    }\n    hover = inCurrentSelection;\n\n    var waveform_subset = [];\n    for (var i = 0; i < hover.length; i++) {\n      var node_index = hover[i];\n      if (node_index < self.waveforms.length) waveform_subset.push(self.waveforms[node_index]);\n    }\n\n    // Clear the canvas\n    self.canvas_hover_ctx.clearRect(0, 0, self.canvas_hover.width, self.canvas_hover.height);\n    // Apply semi transparent background if we are displaying any waveforms\n    if (waveform_subset.length > 0) {\n      self.canvas_hover_ctx.fillRect(0, 0, self.canvas_hover.width, self.canvas_hover.height);\n    }\n\n    var color_scale_and_color_array = self.options.color_scale != null && self.options.color_array != null;\n    var input_index, strokeStyle, coloredLine;\n    for (var i = 0; i < waveform_subset.length; i++) {\n      input_index = waveform_subset[i][\"input-index\"];\n      coloredLine = color_scale_and_color_array && self.options.color_array[input_index] !== null;\n\n      if (coloredLine) {\n        var strokeStyle = self.options.color_scale(self.options.color_array[input_index]);\n      } else {\n        var strokeStyle = $(\"#color-switcher\").colorswitcher(\"get_null_color\");\n        self.canvas_hover_ctx.setLineDash([8, 4]);\n      }\n\n      self.canvas_hover_ctx.strokeStyle = strokeStyle;\n      self.canvas_hover_ctx.stroke(self.paths[input_index]);\n      if (!coloredLine) {\n        self.canvas_hover_ctx.setLineDash([]);\n      }\n    }\n  },\n\n  /* Highlights waveforms */\n  _selection: function _selection(waveforms) {\n    var self = this;\n\n    // Cancel any previously started work\n    self._stopProcessingWaveformsSelection();\n\n    // Only highlight a waveform if it's part of the current selection\n    var selection = self.options.selection;\n    var highlight = self.options.highlight;\n    var inCurrentSelection = [];\n    for (var i = 0; i < highlight.length; i++) {\n      if (selection.indexOf(highlight[i]) > -1) {\n        inCurrentSelection.push(highlight[i]);\n      }\n    }\n    highlight = inCurrentSelection;\n\n    var waveform_subset = [];\n    for (var i = 0; i < highlight.length; i++) {\n      var node_index = highlight[i];\n      if (node_index < self.waveforms.length) waveform_subset.push(self.waveforms[node_index]);\n    }\n\n    // Clear the canvas\n    self.canvas_selection_ctx.clearRect(0, 0, self.canvas_selection.width, self.canvas_selection.height);\n    // If we are displaying any waveforms...\n    if (waveform_subset.length > 0) {\n      // Apply semi transparent background if we are displaying any waveforms\n      self.canvas_selection_ctx.fillRect(0, 0, self.canvas_hover.width, self.canvas_hover.height);\n      // Configure progress indicator max value\n      self.waveformSelectionPie.trigger('configure', {\n        \"max\": waveform_subset.length\n      });\n\n      // Don't want the progress indicator showing up every time. Only if the delay is longer than 1 second.\n      self.showWaveformSelectionPieContainerTimeout = setTimeout(function () {\n        self.waveformSelectionPieContainer.show(0);\n      }, 1000);\n\n      self._timedProcessArray(waveform_subset, processWaveformSelection, finishedProcessingWaveformsSelection, self.waveformSelectionPie, self.waveformSelectionProcessingTimeout);\n      //previewWaveforms(self.canvas_offscreen, self.canvas_datum_ctx);\n    }\n\n    var color_scale_and_color_array = self.options.color_scale != null && self.options.color_array != null;\n    function processWaveformSelection(waveform) {\n      var coloredLine = color_scale_and_color_array && self.options.color_array[waveform[\"input-index\"]] !== null;\n      if (coloredLine) {\n        var strokeStyle = self.options.color_scale(self.options.color_array[waveform[\"input-index\"]]);\n      } else {\n        var strokeStyle = $(\"#color-switcher\").colorswitcher(\"get_null_color\");\n        self.canvas_selection_ctx.setLineDash([8, 4]);\n      }\n      self.canvas_selection_ctx.strokeStyle = strokeStyle;\n      self.canvas_selection_ctx.stroke(self.paths[waveform[\"input-index\"]]);\n\n      if (!coloredLine) {\n        self.canvas_selection_ctx.setLineDash([]);\n      }\n    }\n\n    function finishedProcessingWaveformsSelection() {\n      // Cancelling the timeout that was set to delay progress indicator display\n      clearTimeout(self.showWaveformSelectionPieContainerTimeout);\n      self.waveformSelectionPieContainer.hide();\n\n      // Commenting out intially to see if we can get away without previewing\n      // clearTimeout(self.previewWaveformsSelectionTimeout);\n      // self.previewSelectionWaveformsTimeout = undefined;\n      // self.canvas_datum_ctx.drawImage(self.canvas_offscreen, 0, 0);\n    }\n  },\n\n  _stopProcessingWaveforms: function _stopProcessingWaveforms() {\n    var self = this;\n    // Cancel any previously started work\n    clearTimeout(self.waveformProcessingTimeout.timeoutID);\n    clearTimeout(self.previewWaveformsTimeout);\n    self.previewWaveformsTimeout = undefined;\n    clearTimeout(self.showWaveformPieContainerTimeout);\n    self.waveformPieContainer.hide();\n  },\n\n  _stopProcessingWaveformsSelection: function _stopProcessingWaveformsSelection() {\n    var self = this;\n    // Cancel any previously started work\n    clearTimeout(self.waveformSelectionProcessingTimeout.timeoutID);\n    // Commenting out intially to see if we can get away without previewing\n    // clearTimeout(self.previewWaveformsSelectionTimeout);\n    // self.previewWaveformsSelectionTimeout = undefined;\n    clearTimeout(self.showWaveformSelectionPieContainerTimeout);\n    self.waveformSelectionPieContainer.hide();\n  },\n\n  _timedProcessArray: function _timedProcessArray(items, process, callback, progressControl, windowTimer) {\n    var self = this;\n    var timeout = 100; //how long to yield control to UI thread\n    var todo = items.concat(); //create a clone of the original\n\n    windowTimer.timeoutID = setTimeout(function work() {\n      var start = +new Date();\n      do {\n        process(todo.shift());\n      } while (todo.length > 0 && +new Date() - start < 50);\n\n      if (todo.length > 0) {\n        windowTimer.timeoutID = setTimeout(work, timeout);\n      } else {\n        callback(items);\n      }\n\n      progressControl.val(items.length - todo.length).trigger('change');\n    }, timeout);\n  },\n\n  resize_canvas: function resize_canvas() {\n    this.width = $(\"#waveform-pane\").width();\n    this.height = $(\"#waveform-pane\").height();\n    this.diagram_width = this.width - this.padding_left - this.padding_right;\n    this.diagram_height = this.height - this.padding_top - this.padding_bottom;\n    this._set_visible();\n    this._selection();\n  },\n\n  _setOption: function _setOption(key, value) {\n    //console.log(\"timeseries.waveform._setOption()\", key, value);\n    this.options[key] = value;\n\n    if (key == \"selection\") {\n      this._set_visible();\n    } else if (key == \"highlight\") {\n      this._selection();\n    } else if (key == \"color-options\") {\n      this.options.color_array = value.color_array;\n      this.options.color_scale = value.color_scale;\n\n      this._set_visible();\n      this._selection();\n    } else if (key == \"color_scale\") {\n      this._set_visible();\n      this._selection();\n    } else if (key == \"waveforms\") {\n      this.container.selectAll(\"g.waveform\").remove();\n      this.container.selectAll(\"g.selection\").remove();\n      this.container.selectAll(\"rect.selectionMask\").remove();\n\n      this.options.waveforms = value.waveforms;\n      // Setting selection to all if it's undefined\n      if (value.selection === null) {\n        visible = [];\n        for (var i = 0; i < this.options.waveforms.length; i++) {\n          visible.push(this.options.waveforms[i][\"input-index\"]);\n        }\n        this.options.selection = visible;\n      } else {\n        this.options.selection = value.selection;\n      }\n\n      // Only setting new highlight if one was passed in. Otherwise, leaving the existing one, just like the table does.\n      if (value.highlight !== undefined) this.options.highlight = value.highlight;\n\n      this._set_visible();\n      this._selection();\n    }\n  }\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\")))\n\n//# sourceURL=webpack:///./web-server/plugins/slycat-timeseries-model/js/timeseries-waveformplot.js?");

/***/ }),

/***/ "./web-server/plugins/slycat-timeseries-model/js/ui.js":
/*!*************************************************************!*\
  !*** ./web-server/plugins/slycat-timeseries-model/js/ui.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function($) {\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; /* Copyright (c) 2013, 2018 National Technology and Engineering Solutions of Sandia, LLC . Under the terms of Contract  DE-NA0003525 with National Technology and Engineering Solutions of Sandia, LLC, the U.S. Government  retains certain rights in this software. */\n\nvar _jqueryUi = __webpack_require__(/*! jquery-ui/themes/base/jquery-ui.css */ \"./node_modules/jquery-ui/themes/base/jquery-ui.css\");\n\nvar _jqueryUi2 = _interopRequireDefault(_jqueryUi);\n\nvar _slickGrid = __webpack_require__(/*! css/slickgrid/slick.grid.css */ \"./web-server/css/slickgrid/slick.grid.css\");\n\nvar _slickGrid2 = _interopRequireDefault(_slickGrid);\n\nvar _slickDefaultTheme = __webpack_require__(/*! css/slickgrid/slick-default-theme.css */ \"./web-server/css/slickgrid/slick-default-theme.css\");\n\nvar _slickDefaultTheme2 = _interopRequireDefault(_slickDefaultTheme);\n\nvar _slickHeaderbuttons = __webpack_require__(/*! css/slickgrid/slick.headerbuttons.css */ \"./web-server/css/slickgrid/slick.headerbuttons.css\");\n\nvar _slickHeaderbuttons2 = _interopRequireDefault(_slickHeaderbuttons);\n\nvar _slickSlycatTheme = __webpack_require__(/*! css/slick-slycat-theme.css */ \"./web-server/css/slick-slycat-theme.css\");\n\nvar _slickSlycatTheme2 = _interopRequireDefault(_slickSlycatTheme);\n\nvar _ui = __webpack_require__(/*! ../css/ui.css */ \"./web-server/plugins/slycat-timeseries-model/css/ui.css\");\n\nvar _ui2 = _interopRequireDefault(_ui);\n\nvar _slycatServerRoot = __webpack_require__(/*! js/slycat-server-root */ \"./web-server/js/slycat-server-root.js\");\n\nvar _slycatServerRoot2 = _interopRequireDefault(_slycatServerRoot);\n\nvar _knockout = __webpack_require__(/*! knockout */ \"./node_modules/knockout/build/output/knockout-latest.debug.js\");\n\nvar _knockout2 = _interopRequireDefault(_knockout);\n\nvar _slycatWebClientWebpack = __webpack_require__(/*! js/slycat-web-client-webpack */ \"./web-server/js/slycat-web-client-webpack.js\");\n\nvar _slycatWebClientWebpack2 = _interopRequireDefault(_slycatWebClientWebpack);\n\nvar _slycatBookmarkManagerWebpack = __webpack_require__(/*! js/slycat-bookmark-manager-webpack */ \"./web-server/js/slycat-bookmark-manager-webpack.js\");\n\nvar _slycatBookmarkManagerWebpack2 = _interopRequireDefault(_slycatBookmarkManagerWebpack);\n\nvar _slycatDialogWebpack = __webpack_require__(/*! js/slycat-dialog-webpack */ \"./web-server/js/slycat-dialog-webpack.js\");\n\nvar dialog = _interopRequireWildcard(_slycatDialogWebpack);\n\nvar _urijs = __webpack_require__(/*! urijs */ \"./node_modules/urijs/src/URI.js\");\n\nvar _urijs2 = _interopRequireDefault(_urijs);\n\nvar _chunker = __webpack_require__(/*! ./chunker */ \"./web-server/plugins/slycat-timeseries-model/js/chunker.js\");\n\nvar chunker = _interopRequireWildcard(_chunker);\n\n__webpack_require__(/*! ./timeseries-cluster */ \"./web-server/plugins/slycat-timeseries-model/js/timeseries-cluster.js\");\n\n__webpack_require__(/*! ./timeseries-controls */ \"./web-server/plugins/slycat-timeseries-model/js/timeseries-controls.js\");\n\n__webpack_require__(/*! ./timeseries-legend */ \"./web-server/plugins/slycat-timeseries-model/js/timeseries-legend.js\");\n\n__webpack_require__(/*! ./timeseries-table */ \"./web-server/plugins/slycat-timeseries-model/js/timeseries-table.js\");\n\n__webpack_require__(/*! ./timeseries-dendrogram */ \"./web-server/plugins/slycat-timeseries-model/js/timeseries-dendrogram.js\");\n\n__webpack_require__(/*! ./timeseries-waveformplot */ \"./web-server/plugins/slycat-timeseries-model/js/timeseries-waveformplot.js\");\n\n__webpack_require__(/*! ./color-switcher */ \"./web-server/plugins/slycat-timeseries-model/js/color-switcher.js\");\n\n__webpack_require__(/*! jquery-ui */ \"./node_modules/jquery-ui/jquery-ui.js\");\n\n__webpack_require__(/*! js/jquery.layout-latest.min */ \"./web-server/js/jquery.layout-latest.min.js\");\n\n__webpack_require__(/*! js/slycat-navbar-webpack */ \"./web-server/js/slycat-navbar-webpack.js\");\n\n__webpack_require__(/*! js/slycat-job-checker-webpack */ \"./web-server/js/slycat-job-checker-webpack.js\");\n\nvar _slycatModelMainWebpack = __webpack_require__(/*! js/slycat-model-main-webpack */ \"./web-server/js/slycat-model-main-webpack.js\");\n\nvar slycat_model_main = _interopRequireWildcard(_slycatModelMainWebpack);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// Wait for document ready\n$(document).ready(function () {\n\n  slycat_model_main.start();\n\n  _knockout2.default.applyBindings({}, document.getElementsByClassName('slycat-content')[0]);\n\n  //////////////////////////////////////////////////////////////////////////////////////////\n  // Setup global variables.\n  //////////////////////////////////////////////////////////////////////////////////////////\n\n  var model = { _id: (0, _urijs2.default)(window.location).segment(-1) };\n  var cluster_bin_count = null;\n  var cluster_bin_type = null;\n  var cluster_type = null;\n\n  var bookmarker = null;\n  var bookmark = null;\n\n  var clusters = null; // This is just the list of cluster names\n  var clusters_data = null; // This holds data for each cluster\n  var waveforms_data = null; // This holds the waveforms for each cluster\n  var waveforms_metadata = null; // This holds the waveforms metadata for each cluster\n  var cluster_index = null; // This holds the index of the currently selected cluster\n  var table_metadata = null;\n\n  var color_array = null; // This holds the sorted array of values for the color scale\n  var colorscale = null; // This holds the current color scale\n  var colormap = null; // This hold the current color map\n  var color_variables = null; // This holds the indexes of all the color variables\n  var uniqueValues = null; // This holds the column's unique values for last selected string column\n\n  var selected_column = null; // This holds the currently selected column\n  var selected_column_type = null; // This holds the data type of the currently selected column\n  var selected_column_min = null; // This holds the min value of the currently selected column\n  var selected_column_max = null; // This holds the max value of the currently selected column\n  var selected_simulations = null; // This hold the currently selected rows\n\n  var sort_variable = null; // This holds the sorted variable\n  var sort_order = null; // This holds the sort order\n\n  var collapsed_nodes = null; // This holds the collapsed nodes\n  var expanded_nodes = null; // This holds the expanded nodes\n  var selected_nodes = null; // This holds the selected nodes\n\n  var controls_ready = false;\n  var colorswitcher_ready = false;\n  var dendrogram_ready = false;\n  var waveformplot_ready = false;\n  var table_ready = false;\n  var legend_ready = false;\n\n  var selected_waveform_indexes = null;\n\n  var image_columns = null; // This holds the media columns\n\n  //////////////////////////////////////////////////////////////////////////////////////////\n  // Setup page layout and forms.\n  //////////////////////////////////////////////////////////////////////////////////////////\n\n  // Setup the resizing layout ...\n  var bodyLayout = $(\"#timeseries-model\").layout({\n    applyDefaultStyles: false,\n    north: {\n      size: 28,\n      resizable: false,\n      resizeWhileDragging: false\n    },\n    west: {\n      size: $(\"#timeseries-model\").width() / 2,\n      resizeWhileDragging: false,\n      onresize: function onresize() {\n        $(\"#dendrogram-viewer\").dendrogram(\"resize_canvas\");\n      }\n    },\n    center: {\n      resizeWhileDragging: false,\n      onresize: function onresize() {\n        $(\"#waveform-viewer\").waveformplot(\"resize_canvas\");\n      }\n    },\n    east: {\n      size: 130,\n      resizeWhileDragging: false,\n      onresize: function onresize() {\n        $(\"#legend\").legend(\"option\", { width: $(\"#legend-pane\").width(), height: $(\"#legend-pane\").height() });\n      }\n    },\n    south: {\n      size: $(\"#timeseries-model\").height() / 3,\n      resizeWhileDragging: false,\n      onresize: function onresize() {\n        $(\"#table\").table(\"resize_canvas\");\n      }\n    }\n  });\n\n  //////////////////////////////////////////////////////////////////////////////////////////\n  // Get the model\n  //////////////////////////////////////////////////////////////////////////////////////////\n  function doPoll() {\n    $.ajax({\n      type: \"GET\",\n      url: _slycatServerRoot2.default + \"models/\" + model._id,\n      success: function success(result) {\n        model = result;\n        bookmarker = _slycatBookmarkManagerWebpack2.default.create(model.project, model._id);\n        cluster_bin_count = model[\"artifact:cluster-bin-count\"];\n        cluster_bin_type = model[\"artifact:cluster-bin-type\"];\n        cluster_type = model[\"artifact:cluster-type\"];\n        // If the model isn't ready or failed, we're done.\n        if (model[\"state\"] === \"waiting\" || model[\"state\"] === \"running\") {\n          show_checkjob();\n          setTimeout(doPoll, 15000);\n          return;\n        }\n\n        // Check if model has the image-columns artifact and create one if it doesn't\n        if (!model.hasOwnProperty(\"artifact:image-columns\")) {\n          // Find media columns\n          // console.log(\"This model has no artifact:image-columns\");\n          _slycatWebClientWebpack2.default.get_model_command({\n            mid: model._id,\n            type: \"timeseries\",\n            command: \"media-columns\",\n            success: function success(media_columns) {\n              // console.log(\"here are the media_columns: \" + media_columns);\n              _slycatWebClientWebpack2.default.put_model_parameter({\n                mid: model._id,\n                aid: \"image-columns\",\n                value: media_columns,\n                input: true,\n                success: function success() {\n                  // console.log(\"successfully saved image-columns\");\n                  image_columns = media_columns;\n                }\n              });\n            },\n            error: function error(_error) {\n              console.log(\"error getting model command\");\n            }\n          });\n        } else {\n          image_columns = model[\"artifact:image-columns\"];\n        }\n\n        $('.slycat-job-checker').remove();\n\n        if (model[\"state\"] == \"closed\" && model[\"result\"] === null) return;\n        if (model[\"result\"] == \"failed\") return;\n        setup_page();\n      },\n      error: function error(request, status, reason_phrase) {\n        window.alert(\"Error retrieving model: \" + reason_phrase);\n      }\n    });\n  }\n  doPoll();\n\n  //////////////////////////////////////////////////////////////////////////////////////////\n  // If the model is ready, start retrieving data, including bookmarked state.\n  //////////////////////////////////////////////////////////////////////////////////////////\n\n  function s_to_a(s) {\n    if (Array.isArray(s)) return s;else return JSON.parse(s);\n  }\n\n  function s_to_o(s) {\n    if ((typeof s === \"undefined\" ? \"undefined\" : _typeof(s)) === \"object\") return s;else return JSON.parse(s);\n  }\n\n  var show_checkjob = function show_checkjob() {\n    var jc = $('#timeseries-model').children()[0];\n    var $jc = $(jc);\n    $jc.detach();\n\n    $($('#timeseries-model').children()).remove();\n    $('#timeseries-model').append($jc);\n\n    var vm = _knockout2.default.dataFor($('.slycat-job-checker')[0]);\n    vm.set_jid(model['artifact:jid']);\n  };\n\n  function setup_page() {\n\n    // Display progress as the load happens ...\n    $(\".load-status\").text(\"Loading data.\");\n\n    // Load list of clusters.\n    $.ajax({\n      url: _slycatServerRoot2.default + \"models/\" + model._id + \"/files/clusters\",\n      contentType: \"application/json\",\n      success: function success(result) {\n        clusters = result;\n        clusters_data = new Array(clusters.length);\n        waveforms_data = new Array(clusters.length);\n        waveforms_metadata = new Array(clusters.length);\n        setup_widgets();\n        retrieve_bookmarked_state();\n      },\n      error: artifact_missing\n    });\n\n    // Load data table metadata.\n    $.ajax({\n      url: _slycatServerRoot2.default + \"models/\" + model._id + \"/tables/inputs/arrays/0/metadata?index=Index\",\n      contentType: \"application/json\",\n      success: function success(metadata) {\n        table_metadata = metadata;\n        setup_widgets();\n        setup_colordata();\n        retrieve_bookmarked_state();\n      },\n      error: artifact_missing\n    });\n\n    // Retrieve bookmarked state information ...\n    function retrieve_bookmarked_state() {\n      if (table_metadata !== null && clusters !== null) {\n        bookmarker.getState(function (state) {\n          bookmark = state;\n\n          // Set state of selected cluster\n          cluster_index = bookmark[\"cluster-index\"] !== undefined ? bookmark[\"cluster-index\"] : 0;\n\n          // Set state of selected simulations\n          selected_simulations = [];\n          if (\"simulation-selection\" in bookmark) selected_simulations = bookmark[\"simulation-selection\"];else if (\"cluster-index\" in bookmark && bookmark[\"cluster-index\"] + \"-selected-row-simulations\" in bookmark) {\n            selected_simulations = bookmark[bookmark[\"cluster-index\"] + \"-selected-row-simulations\"];\n          }\n\n          // Set state of selected column\n          selected_column = [];\n          selected_column_type = [];\n          selected_column_min = [];\n          selected_column_max = [];\n          for (var i = 0; i < clusters.length; i++) {\n            selected_column[i] = bookmark[i + \"-column-index\"] !== undefined ? bookmark[i + \"-column-index\"] : table_metadata[\"column-count\"] - 1;\n            selected_column_type[i] = table_metadata[\"column-types\"][selected_column[i]];\n            selected_column_min[i] = table_metadata[\"column-min\"][selected_column[i]];\n            selected_column_max[i] = table_metadata[\"column-max\"][selected_column[i]];\n          }\n\n          // Set state of color variable\n          color_variables = [];\n          for (var i = 0; i < table_metadata[\"column-count\"]; i++) {\n            if (image_columns != undefined && image_columns.indexOf(i) == -1) color_variables.push(i);\n          }\n          // Move index column to top\n          color_variables.unshift(color_variables.pop());\n\n          // Set state of selected waveform indexes\n          selected_waveform_indexes = [];\n          for (var i = 0; i < clusters.length; i++) {\n            selected_waveform_indexes[i] = bookmark[i + \"-selected-waveform-indexes\"] !== undefined ? bookmark[i + \"-selected-waveform-indexes\"] : null;\n          }\n\n          // Set state of colormap\n          colormap = bookmark[\"colormap\"] !== undefined ? bookmark[\"colormap\"] : \"night\";\n\n          // Set sort variable and order\n          sort_variable = bookmark[\"sort-variable\"] != undefined ? bookmark[\"sort-variable\"] : undefined;\n          sort_order = bookmark[\"sort-order\"] != undefined ? bookmark[\"sort-order\"] : undefined;\n\n          // Set collapsed, expanded, and selected nodes\n          collapsed_nodes = [];\n          expanded_nodes = [];\n          selected_nodes = [];\n          for (var i = 0; i < clusters.length; i++) {\n            collapsed_nodes[i] = bookmark[i + \"-collapsed-nodes\"];\n            expanded_nodes[i] = bookmark[i + \"-expanded-nodes\"];\n            selected_nodes[i] = bookmark[i + \"-selected-nodes\"];\n          }\n\n          setup_widgets();\n          setup_colordata();\n        });\n      }\n    }\n  }\n\n  function artifact_missing() {\n    $(\".load-status\").css(\"display\", \"none\");\n\n    dialog.dialog({\n      title: \"Load Error\",\n      message: \"Oops, there was a problem retrieving data from the model. This likely means that there was a problem during computation.\"\n    });\n  }\n\n  //////////////////////////////////////////////////////////////////////////////////////////\n  // Setup the rest of the UI as data is received.\n  //////////////////////////////////////////////////////////////////////////////////////////\n\n  function setup_colordata() {\n    if (bookmark && table_metadata && selected_column != null && cluster_index !== null) {\n      retrieve_sorted_column({\n        column: selected_column[cluster_index],\n        callback: function callback(array) {\n          setup_widgets();\n        }\n      });\n    }\n  }\n\n  // Retrieve a column of data, sorted by the index. Saves it in color_array and executes callback, passing the column data array to it.\n  function retrieve_sorted_column(parameters) {\n    //Grabbing all values for current column\n    var lastColumn = table_metadata[\"column-count\"] - 1;\n    var firstRow = table_metadata[\"column-min\"][lastColumn];\n    var lastRow = table_metadata[\"column-max\"][lastColumn] + 1;\n\n    $.ajax({\n      url: _slycatServerRoot2.default + \"models/\" + model._id + \"/tables/inputs/arrays/0/chunk?rows=\" + firstRow + \"-\" + lastRow + \"&columns=\" + parameters.column + \"&index=Index&sort=\" + lastColumn + \":ascending\",\n      async: true,\n      callback: parameters.callback,\n      success: function success(resp) {\n        color_array = resp[\"data\"][0];\n        this.callback(resp[\"data\"][0]);\n      },\n      error: function error(request, status, reason_phrase) {\n        window.alert(\"Error getting color coding values from table-chunker worker: \" + reason_phrase);\n      }\n    });\n  }\n\n  function setup_widgets() {\n    // Setup waveforms ...\n    if (bookmark && s_to_a(clusters) && cluster_index !== null && waveforms_data[cluster_index] === undefined && waveforms_metadata[cluster_index] === undefined) {\n      waveforms_data[cluster_index] = null;\n      waveforms_metadata[cluster_index] = null;\n\n      // Load the waveforms.\n      chunker.get_model_arrayset({\n        server_root: _slycatServerRoot2.default + \"\",\n        mid: model._id,\n        aid: \"preview-\" + s_to_a(clusters)[cluster_index],\n        success: function success(result, metadata) {\n          waveforms_data[cluster_index] = result;\n          waveforms_metadata[cluster_index] = metadata;\n          setup_widgets();\n        },\n        error: artifact_missing\n      });\n    }\n\n    // Setup clusters data ...\n    if (bookmark && s_to_a(clusters) && clusters_data[cluster_index] === undefined) {\n      clusters_data[cluster_index] = null;\n      $.ajax({\n        url: _slycatServerRoot2.default + \"models/\" + model._id + \"/files/cluster-\" + s_to_a(clusters)[cluster_index],\n        contentType: \"application/json\",\n        success: function success(cluster_data) {\n          clusters_data[cluster_index] = cluster_data;\n          setup_widgets();\n        },\n        error: artifact_missing\n      });\n    }\n\n    // Setup controls ...\n    if (!controls_ready && bookmark && s_to_a(clusters) && cluster_index !== null && selected_simulations != null && table_metadata && color_variables !== null && selected_waveform_indexes !== null && selected_column !== null && cluster_index !== null) {\n      controls_ready = true;\n\n      $(\"#cluster-pane .load-status\").css(\"display\", \"none\");\n\n      var controls_options = {\n        mid: model._id,\n        model_name: model_name,\n        aid: \"inputs\",\n        metadata: table_metadata,\n        highlight: selected_simulations,\n        clusters: s_to_a(clusters),\n        cluster: cluster_index,\n        color_variables: color_variables,\n        \"color-variable\": selected_column[cluster_index],\n        \"selection\": selected_waveform_indexes[parseInt(cluster_index, 10)],\n        image_columns: image_columns\n      };\n\n      $(\"#controls\").controls(controls_options);\n\n      // Changes to the cluster selection ...\n      $(\"#controls\").bind(\"cluster-changed\", function (event, cluster) {\n        // Handle changes to the cluster selection ...\n        selected_cluster_changed(cluster);\n      });\n\n      // Changes to the waveform color ...\n      $(\"#controls\").bind(\"color-selection-changed\", function (event, variable) {\n        variable = parseInt(variable);\n        selected_variable_changed(variable);\n        $(\"#table\").table(\"option\", \"variable-selection\", [selected_column[cluster_index]]);\n      });\n    }\n\n    // Setup the color switcher ...\n    if (!colorswitcher_ready && bookmark && colormap !== null) {\n      colorswitcher_ready = true;\n      $(\"#color-switcher\").colorswitcher({ colormap: colormap });\n\n      update_current_colorscale(setup_widgets);\n\n      $(\"#color-switcher\").bind(\"colormap-changed\", function (event, newColormap) {\n        selected_colormap_changed(newColormap);\n      });\n    }\n\n    // Setup the legend ...\n    if (!legend_ready && bookmark && table_metadata && cluster_index !== null && colormap !== null && selected_column !== null && selected_column_type !== null && colorscale !== null) {\n      legend_ready = true;\n\n      $(\"#legend-pane .load-status\").css(\"display\", \"none\");\n\n      $(\"#legend-pane\").css(\"background\", $(\"#color-switcher\").colorswitcher(\"get_background\", colormap).toString());\n\n      $(\"#legend\").legend({\n        width: $(\"#legend-pane\").width(),\n        height: $(\"#legend-pane\").height(),\n        gradient: $(\"#color-switcher\").colorswitcher(\"get_gradient_data\", colormap),\n        label: table_metadata[\"column-names\"][selected_column[cluster_index]],\n        min: table_metadata[\"column-min\"][selected_column[cluster_index]],\n        max: table_metadata[\"column-max\"][selected_column[cluster_index]],\n        v_type: selected_column_type[cluster_index],\n        uniqueValues: uniqueValues\n      });\n    }\n\n    // Setup the waveform plot ...\n    if (!waveformplot_ready && bookmark && cluster_index !== null && waveforms_data !== null && waveforms_data[cluster_index] !== undefined && waveforms_data[cluster_index] !== null && color_array !== null && colorscale !== null && table_metadata !== null && selected_simulations !== null && selected_waveform_indexes !== null) {\n      waveformplot_ready = true;\n\n      $(\"#waveform-pane .load-status\").css(\"display\", \"none\");\n\n      $(\"#waveform-pane\").css({\n        \"background-color\": $(\"#color-switcher\").colorswitcher(\"get_background\", colormap).toString()\n      });\n      $(\"#waveform-viewer rect.selectionMask\").css({\n        \"fill\": $(\"#color-switcher\").colorswitcher(\"get_background\", colormap).toString(),\n        \"fill-opacity\": $(\"#color-switcher\").colorswitcher(\"get_opacity\", colormap)\n      });\n\n      var waveformplot_options = {\n        \"server-root\": _slycatServerRoot2.default,\n        mid: model._id,\n        waveforms: waveforms_data[cluster_index],\n        color_scale: colorscale,\n        color_array: color_array,\n        highlight: selected_simulations,\n        \"selection\": selected_waveform_indexes[parseInt(cluster_index, 10)]\n      };\n\n      $(\"#waveform-viewer\").waveformplot(waveformplot_options);\n\n      // Changing the waveform selection ...\n      $(\"#waveform-viewer\").bind(\"waveform-selection-changed\", function (event, waveform_indexes) {\n        // Log changes to the waveform selection\n        selected_simulations_changed(waveform_indexes);\n        // Updates the dendrogram ...\n        $(\"#dendrogram-viewer\").dendrogram(\"option\", \"highlight\", waveform_indexes);\n        // Updates the controls ...\n        $(\"#controls\").controls(\"option\", \"highlight\", waveform_indexes);\n        // Updates the table row selection ...\n        $(\"#table\").table(\"option\", \"row-selection\", waveform_indexes);\n      });\n    }\n\n    // Setup the table ...\n    if (!table_ready && bookmark && table_metadata && cluster_index !== null && selected_simulations !== null && colormap !== null && colorscale !== null && selected_column !== null && selected_column_type !== null && selected_column_min !== null && selected_column_max !== null && sort_variable !== null && sort_order !== null && image_columns !== null) {\n      table_ready = true;\n\n      $(\"#table-pane .load-status\").css(\"display\", \"none\");\n\n      var table_options = {\n        \"server-root\": _slycatServerRoot2.default,\n        mid: model._id,\n        aid: \"inputs\",\n        metadata: table_metadata,\n        colorscale: colorscale,\n        colormap: colormap,\n        \"variable-selection\": [selected_column[cluster_index]],\n        \"row-selection\": selected_simulations,\n        \"sort-variable\": sort_variable,\n        \"sort-order\": sort_order,\n        image_columns: image_columns\n      };\n\n      $(\"#table\").table(table_options);\n\n      // Changing the table row selection ...\n      $(\"#table\").bind(\"row-selection-changed\", function (event, waveform_indexes) {\n        // Log changes to the table row selection\n        selected_simulations_changed(waveform_indexes);\n        // Update the controls ...\n        $(\"#controls\").controls(\"option\", \"highlight\", waveform_indexes);\n        // Update the waveform plot ...\n        $(\"#waveform-viewer\").waveformplot(\"option\", \"highlight\", waveform_indexes);\n        // Changing the table row selection updates the dendrogram ...\n        $(\"#dendrogram-viewer\").dendrogram(\"option\", \"highlight\", waveform_indexes);\n      });\n\n      // Changing table's sort order ...\n      $(\"#table\").bind(\"variable-sort-changed\", function (event, variable, order) {\n        // Log changes to the table sort order ...\n        variable_sort_changed(variable, order);\n        // Updated the dendrogram sort control\n        $(\"#dendrogram-viewer\").dendrogram(\"option\", \"dendrogram_sort_order\", variable == null && order == null ? true : false);\n      });\n\n      // Changing the table variable selection logs it, updates the waveform plot and dendrogram...\n      $(\"#table\").bind(\"variable-selection-changed\", function (event, parameters) {\n        selected_variable_changed(parameters.variable[0]);\n        $(\"#controls\").controls(\"option\", \"color-variable\", selected_column[cluster_index]);\n      });\n    }\n\n    // Setup the dendrogram ...\n    if (!dendrogram_ready && bookmark && s_to_a(clusters) && cluster_index !== null && clusters_data[cluster_index] !== undefined && clusters_data[cluster_index] !== null && color_array !== null && colorscale !== null && selected_simulations !== null && colormap !== null && selected_column_min !== null && selected_column_max !== null && sort_variable !== null) {\n      dendrogram_ready = true;\n\n      $(\"#dendrogram-pane .load-status\").css(\"display\", \"none\");\n\n      $(\"#dendrogram-sparkline-backdrop\").css({\n        \"background-color\": $(\"#color-switcher\").colorswitcher(\"get_background\", colormap).toString()\n      });\n\n      var dendrogram_options = build_dendrogram_node_options(cluster_index);\n      dendrogram_options[\"server-root\"] = _slycatServerRoot2.default;\n      dendrogram_options.mid = model._id;\n      dendrogram_options.clusters = s_to_a(clusters);\n      dendrogram_options.cluster_data = s_to_o(clusters_data[cluster_index]);\n      dendrogram_options.color_scale = colorscale;\n      dendrogram_options.color_array = color_array;\n\n      if (sort_variable != undefined) {\n        dendrogram_options.dendrogram_sort_order = false;\n      }\n\n      // Respond to note selection changes. This needs to be above the instantiation of the dendrogram\n      // because the table needs to know which node is selected in order for it to initialize. If this\n      // event handler is registered after the dendrogram is initialized, its first node-selection-changed\n      // event never makes it to the table and we end up with a blank table.\n      $(\"#dendrogram-viewer\").bind(\"node-selection-changed\", function (event, parameters) {\n        selected_node_changed(parameters);\n      });\n\n      $(\"#dendrogram-viewer\").dendrogram(dendrogram_options);\n\n      // Bookmark changes to expanded and collapsed nodes ...\n      $(\"#dendrogram-viewer\").bind(\"expanded-collapsed-nodes-changed\", function (event, nodes) {\n        expanded_collapsed_nodes_changed(nodes);\n      });\n\n      // Log changes to node toggle ...\n      $(\"#dendrogram-viewer\").bind(\"node-toggled\", function (event, node) {\n        node_toggled(node);\n      });\n\n      // Changing the dendrogram waveform selection ...\n      $(\"#dendrogram-viewer\").bind(\"waveform-selection-changed\", function (event, waveform_indexes) {\n        // Log changes to the waveform selection\n        selected_simulations_changed(waveform_indexes);\n        // Update the controls ...\n        $(\"#controls\").controls(\"option\", \"highlight\", waveform_indexes);\n        // Update the waveform plot ...\n        $(\"#waveform-viewer\").waveformplot(\"option\", \"highlight\", waveform_indexes);\n        // Update the table row selection ...\n        $(\"#table\").table(\"option\", \"row-selection\", waveform_indexes);\n      });\n\n      // Changing the sort order to dendrogram order updates the table ...\n      $(\"#dendrogram-viewer\").bind(\"sort-by-dendrogram-order\", function (event) {\n        $(\"#table\").table(\"option\", \"sort-variable\", null);\n      });\n\n      // Changes to the cluster selection ...\n      $(\"#dendrogram-viewer\").bind(\"cluster-changed\", function (event, cluster) {\n        // Handle changes to the cluster selection ...\n        selected_cluster_changed(cluster);\n      });\n    }\n  }\n\n  //////////////////////////////////////////////////////////////////////////////////////////\n  // Event handlers.\n  //////////////////////////////////////////////////////////////////////////////////////////\n\n  function selected_colormap_changed(newColormap) {\n    colormap = newColormap;\n\n    // First we change background colors, gradients, and other things that don't require recalculating the colorscale\n    $(\"#legend-pane\").css(\"background\", $(\"#color-switcher\").colorswitcher(\"get_background\", colormap).toString());\n    $(\"#legend\").legend(\"option\", { gradient: $(\"#color-switcher\").colorswitcher(\"get_gradient_data\", colormap) });\n\n    $(\"#dendrogram-sparkline-backdrop\").css({\n      \"background-color\": $(\"#color-switcher\").colorswitcher(\"get_background\", colormap).toString()\n    });\n\n    $(\"#waveform-pane\").css({\n      \"background-color\": $(\"#color-switcher\").colorswitcher(\"get_background\", colormap).toString()\n    });\n    $(\"#waveform-viewer rect.selectionMask\").css({\n      \"fill\": $(\"#color-switcher\").colorswitcher(\"get_background\", colormap).toString(),\n      \"fill-opacity\": $(\"#color-switcher\").colorswitcher(\"get_opacity\", colormap)\n    });\n\n    // Now we get the new colorscale and update components\n    update_waveform_dendrogram_table_legend_on_selected_variable_changed();\n\n    $.ajax({\n      type: \"POST\",\n      url: _slycatServerRoot2.default + \"events/models/\" + model._id + \"/select/colormap/\" + colormap\n    });\n    bookmarker.updateState({ \"colormap\": colormap });\n  }\n\n  function selected_cluster_changed(cluster) {\n    cluster_index = cluster;\n\n    // Changing the cluster updates the dendrogram and waveformplot ...\n    update_dendrogram(cluster_index);\n    update_waveformplot(cluster_index);\n\n    // Changing the cluster updates the table variable selection ...\n    $(\"#table\").table(\"option\", \"variable-selection\", [selected_column[cluster_index]]);\n    $(\"#controls\").controls(\"option\", \"color-variable\", selected_column[cluster_index]);\n    update_waveform_dendrogram_table_legend_on_selected_variable_changed();\n\n    $.ajax({\n      type: \"POST\",\n      url: _slycatServerRoot2.default + \"events/models/\" + model._id + \"/select/cluster/\" + cluster_index\n    });\n    bookmarker.updateState({ \"cluster-index\": cluster_index });\n  }\n\n  function selected_node_changed(parameters) {\n    selected_waveform_indexes[parseInt(cluster_index, 10)] = getWaveformIndexes(parameters.selection);\n    selected_nodes[cluster_index] = getNodeIndexes(parameters.selection);\n\n    // Only want to update the controls if the user changed the selected node. It's automatically set at dendrogram creation time, and we want to avoid updating the controls at that time.\n    // Only want to update the waveform plot if the user changed the selected node. It's automatically set at dendrogram creation time, and we want to avoid updating the waveform plot at that time.\n    if (parameters.skip_bookmarking != true) {\n      // Changing the selected dendrogram node updates the controls ...\n      $(\"#controls\").controls(\"option\", \"selection\", selected_waveform_indexes[parseInt(cluster_index, 10)]);\n      $(\"#controls\").controls(\"option\", \"highlight\", selected_simulations);\n\n      // Changing the selected dendrogram node updates the waveform plot ...\n      $(\"#waveform-viewer\").waveformplot(\"option\", \"selection\", selected_waveform_indexes[parseInt(cluster_index, 10)]);\n      $(\"#waveform-viewer\").waveformplot(\"option\", \"highlight\", selected_simulations);\n\n      // Update bookmark\n      var state = {};\n      state[cluster_index + \"-selected-nodes\"] = selected_nodes[cluster_index];\n      state[cluster_index + \"-selected-waveform-indexes\"] = selected_waveform_indexes[parseInt(cluster_index, 10)];\n      bookmarker.updateState(state);\n    }\n\n    // Changing the selected dendrogram node updates the table ...\n    $(\"#table\").table(\"option\", \"row-selection-silent\", selected_simulations);\n    $(\"#table\").table(\"option\", \"selection\", parameters.selection);\n\n    // Post analytics\n    if (parameters.node != null && parameters.node[\"node-index\"] != null) {\n      $.ajax({\n        type: \"POST\",\n        url: _slycatServerRoot2.default + \"events/models/\" + model._id + \"/select/node/\" + parameters.node[\"node-index\"]\n      });\n    }\n  }\n\n  function selected_simulations_changed(selection) {\n    selected_simulations = selection;\n    // Logging every selected item is too slow, so just log the count instead.\n    $.ajax({\n      type: \"POST\",\n      url: _slycatServerRoot2.default + \"events/models/\" + model._id + \"/select/simulation/count/\" + selected_simulations.length\n    });\n    var bookmark_selected_simulations = {};\n    bookmark_selected_simulations[\"simulation-selection\"] = selected_simulations;\n    bookmarker.updateState(bookmark_selected_simulations);\n  }\n\n  function selected_variable_changed(variable) {\n    selected_column[cluster_index] = variable;\n    selected_column_type[cluster_index] = table_metadata[\"column-types\"][selected_column[cluster_index]];\n    selected_column_min[cluster_index] = table_metadata[\"column-min\"][selected_column[cluster_index]];\n    selected_column_max[cluster_index] = table_metadata[\"column-max\"][selected_column[cluster_index]];\n\n    update_waveform_dendrogram_table_legend_on_selected_variable_changed();\n\n    $.ajax({\n      type: \"POST\",\n      url: _slycatServerRoot2.default + \"events/models/\" + model._id + \"/select/variable/\" + selected_column[cluster_index]\n    });\n    var selected_variable = {};\n    selected_variable[cluster_index + \"-column-index\"] = selected_column[cluster_index];\n    bookmarker.updateState(selected_variable);\n  }\n\n  function update_current_colorscale(callback) {\n    if (selected_column_type[cluster_index] != \"string\") {\n      colorscale = $(\"#color-switcher\").colorswitcher(\"get_color_scale\", undefined, selected_column_min[cluster_index], selected_column_max[cluster_index]);\n      callback(colorscale);\n    } else {\n      $.ajax({\n        type: \"GET\",\n        url: _slycatServerRoot2.default + \"models/\" + model._id + \"/arraysets/inputs/metadata?unique=0/\" + selected_column[cluster_index] + \"/...\",\n        success: function success(result) {\n          uniqueValues = result.unique[0].values[0];\n          colorscale = $(\"#color-switcher\").colorswitcher(\"get_color_scale_ordinal\", undefined, uniqueValues);\n          callback(colorscale);\n        },\n        error: function error(result) {\n          console.log(\"there was an error. here it is: \" + result);\n        }\n      });\n    }\n  }\n\n  function update_waveform_dendrogram_table_legend_on_selected_variable_changed() {\n    update_current_colorscale(function (colorscale) {\n      retrieve_sorted_column({\n        column: selected_column[cluster_index],\n        callback: function callback(array) {\n          var parameters = {\n            color_array: array,\n            color_scale: colorscale\n          };\n\n          $(\"#waveform-viewer\").waveformplot(\"option\", \"color-options\", parameters);\n          $(\"#dendrogram-viewer\").dendrogram(\"option\", \"color-options\", parameters);\n          $(\"#table\").table(\"option\", \"colorscale\", colorscale);\n          $(\"#legend\").legend(\"option\", {\n            min: table_metadata[\"column-min\"][selected_column[cluster_index]],\n            max: table_metadata[\"column-max\"][selected_column[cluster_index]],\n            label: table_metadata[\"column-names\"][selected_column[cluster_index]],\n            v_type: selected_column_type[cluster_index],\n            uniqueValues: uniqueValues\n          });\n        }\n      });\n    });\n  }\n\n  function variable_sort_changed(variable, order) {\n    sort_variable = variable;\n    sort_order = order;\n\n    $.ajax({\n      type: \"POST\",\n      url: _slycatServerRoot2.default + \"events/models/\" + model._id + \"/select/sort-order/\" + variable + \"/\" + order\n    });\n    bookmarker.updateState({ \"sort-variable\": sort_variable, \"sort-order\": sort_order });\n  }\n\n  function expanded_collapsed_nodes_changed(nodes) {\n    collapsed_nodes[cluster_index] = nodes.collapsed;\n    expanded_nodes[cluster_index] = nodes.expanded;\n\n    var cluster_state = {};\n    cluster_state[cluster_index + \"-expanded-nodes\"] = expanded_nodes[cluster_index];\n    cluster_state[cluster_index + \"-collapsed-nodes\"] = collapsed_nodes[cluster_index];\n    bookmarker.updateState(cluster_state);\n  }\n\n  function node_toggled(node) {\n    $.ajax({\n      type: \"POST\",\n      url: _slycatServerRoot2.default + \"events/models/\" + model._id + \"/toggle/node/\" + node[\"node-index\"]\n    });\n  }\n\n  function update_dendrogram(cluster) {\n    // Retrieve cluster data if it's not already in the cache\n    if (clusters_data[cluster] === undefined || clusters_data[cluster] === null) {\n      $.ajax({\n        url: _slycatServerRoot2.default + \"models/\" + model._id + \"/files/cluster-\" + s_to_a(clusters)[cluster],\n        contentType: \"application/json\",\n        success: function success(cluster_data) {\n          clusters_data[cluster] = cluster_data;\n          var dendrogram_options = build_dendrogram_node_options(cluster);\n          dendrogram_options.cluster_data = s_to_o(clusters_data[cluster]);\n          $(\"#dendrogram-viewer\").dendrogram(\"option\", dendrogram_options);\n        },\n        error: artifact_missing\n      });\n    } else {\n      var dendrogram_options = build_dendrogram_node_options(cluster);\n      dendrogram_options.cluster_data = s_to_o(clusters_data[cluster]);\n      $(\"#dendrogram-viewer\").dendrogram(\"option\", dendrogram_options);\n    }\n  }\n\n  function update_waveformplot(cluster) {\n    // Retrieve waveform data if it's not already in the cache\n    if (waveforms_data[cluster] === undefined) {\n      // Load the waveforms.\n      chunker.get_model_arrayset({\n        server_root: _slycatServerRoot2.default,\n        mid: model._id,\n        aid: \"preview-\" + s_to_a(clusters)[cluster],\n        success: function success(result, metadata) {\n          waveforms_data[cluster] = result;\n          waveforms_metadata[cluster] = metadata;\n          var waveformplot_options = {\n            waveforms: waveforms_data[cluster],\n            selection: selected_waveform_indexes[cluster],\n            highlight: selected_simulations\n          };\n          $(\"#waveform-viewer\").waveformplot(\"option\", \"waveforms\", waveformplot_options);\n        },\n        error: artifact_missing\n      });\n    } else {\n      var waveformplot_options = {\n        waveforms: waveforms_data[cluster],\n        selection: selected_waveform_indexes[cluster],\n        highlight: selected_simulations\n      };\n      $(\"#waveform-viewer\").waveformplot(\"option\", \"waveforms\", waveformplot_options);\n    }\n  }\n\n  function build_dendrogram_node_options(cluster) {\n    var dendrogram_options = {\n      cluster: cluster\n    };\n\n    dendrogram_options.collapsed_nodes = collapsed_nodes[cluster];\n    dendrogram_options.expanded_nodes = expanded_nodes[cluster];\n    dendrogram_options.selected_nodes = selected_nodes[cluster];\n    dendrogram_options.highlight = selected_simulations;\n\n    return dendrogram_options;\n  }\n\n  function getWaveformIndexes(nodes) {\n    var waveform_indexes = [];\n    var waveform_index = null;\n\n    $.each(nodes, function (index, node) {\n      waveform_index = node[\"waveform-index\"];\n      if (waveform_index != null) waveform_indexes.push(waveform_index);\n    });\n\n    return waveform_indexes;\n  }\n\n  function getNodeIndexes(nodes) {\n    var node_indexes = [];\n    var node_index = null;\n\n    for (var i = 0; i < nodes.length; i++) {\n      node_index = nodes[i][\"node-index\"];\n      if (node_index != null) node_indexes.push(node_index);\n    }\n\n    return node_indexes;\n  }\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\")))\n\n//# sourceURL=webpack:///./web-server/plugins/slycat-timeseries-model/js/ui.js?");

/***/ })

/******/ });